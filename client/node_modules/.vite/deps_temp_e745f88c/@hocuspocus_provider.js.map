{
  "version": 3,
  "sources": ["../../node_modules/lib0/math.js", "../../node_modules/lib0/binary.js", "../../node_modules/lib0/number.js", "../../node_modules/lib0/string.js", "../../node_modules/lib0/encoding.js", "../../node_modules/lib0/error.js", "../../node_modules/lib0/decoding.js", "../../@hocuspocus/common/src/auth.ts", "../../@hocuspocus/common/src/CloseEvents.ts", "../../@hocuspocus/common/src/awarenessStatesToArray.ts", "../../@hocuspocus/common/src/types.ts", "../../@lifeomic/attempt/dist/es6/src/index.js", "../../node_modules/lib0/map.js", "../../node_modules/lib0/set.js", "../../node_modules/lib0/array.js", "../../node_modules/lib0/string.js", "../../node_modules/lib0/conditions.js", "../../node_modules/lib0/storage.js", "../../node_modules/lib0/object.js", "../../node_modules/lib0/function.js", "../../node_modules/lib0/environment.js", "../../node_modules/lib0/math.js", "../../node_modules/lib0/binary.js", "../../node_modules/lib0/number.js", "../../node_modules/lib0/encoding.js", "../../node_modules/lib0/error.js", "../../node_modules/lib0/decoding.js", "../../node_modules/lib0/buffer.js", "../../node_modules/lib0/broadcastchannel.js", "../../node_modules/lib0/mutex.js", "../../node_modules/lib0/time.js", "../../node_modules/lib0/observable.js", "../../node_modules/y-protocols/awareness.js", "../../@hocuspocus/provider/src/EventEmitter.ts", "../../node_modules/lib0/url.js", "../../@hocuspocus/provider/src/types.ts", "../../@hocuspocus/provider/src/IncomingMessage.ts", "../../@hocuspocus/provider/src/HocuspocusProviderWebsocket.ts", "../../node_modules/y-protocols/sync.js", "../../@hocuspocus/provider/src/OutgoingMessage.ts", "../../@hocuspocus/provider/src/MessageReceiver.ts", "../../@hocuspocus/provider/src/MessageSender.ts", "../../@hocuspocus/provider/src/OutgoingMessages/AuthenticationMessage.ts", "../../@hocuspocus/provider/src/OutgoingMessages/AwarenessMessage.ts", "../../@hocuspocus/provider/src/OutgoingMessages/CloseMessage.ts", "../../@hocuspocus/provider/src/OutgoingMessages/QueryAwarenessMessage.ts", "../../@hocuspocus/provider/src/OutgoingMessages/StatelessMessage.ts", "../../@hocuspocus/provider/src/OutgoingMessages/SyncStepOneMessage.ts", "../../@hocuspocus/provider/src/OutgoingMessages/SyncStepTwoMessage.ts", "../../@hocuspocus/provider/src/OutgoingMessages/UpdateMessage.ts", "../../@hocuspocus/provider/src/HocuspocusProvider.ts", "../../node_modules/lib0/webcrypto.js", "../../node_modules/lib0/random.js", "../../@hocuspocus/provider/src/TiptapCollabProviderWebsocket.ts", "../../@hocuspocus/provider/src/TiptapCollabProvider.ts"],
  "sourcesContent": ["/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n", "/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n", "/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\nexport const HIGHEST_INT32 = binary.BITS31\nexport const HIGHEST_UINT32 = binary.BITS32\n\n/* c8 ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\nexport const parseInt = Number.parseInt\n\n/**\n * Count the number of \"1\" bits in an unsigned 32bit number.\n *\n * Super fun bitcount algorithm by Brian Kernighan.\n *\n * @param {number} n\n */\nexport const countBits = n => {\n  n &= binary.BITS32\n  let count = 0\n  while (n) {\n    n &= (n - 1)\n    count++\n  }\n  return count\n}\n", "import * as array from './array.js'\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * The largest utf16 character.\n * Corresponds to Uint8Array([255, 255]) or charcodeof(2x2^8)\n */\nexport const MAX_UTF16_CHARACTER = fromCharCode(65535)\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* c8 ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* c8 ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* c8 ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nexport const splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n\n/**\n * @param {string} source\n * @param {number} n\n */\nexport const repeat = (source, n) => array.unfold(n, () => source).join('')\n", "/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\nimport * as string from './string.js'\nimport * as array from './array.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * @param {function(Encoder):void} f\n */\nexport const encode = (f) => {\n  const encoder = createEncoder()\n  f(encoder)\n  return toUint8Array(encoder)\n}\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nexport const hasContent = encoder => encoder.cpos > 0 || encoder.bufs.length > 0\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nexport const verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num = math.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, string.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nexport const writeVarString = (string.utf8TextEncoder && /** @type {any} */ (string.utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write a string terminated by a special byte sequence. This is not very performant and is\n * generally discouraged. However, the resulting byte arrays are lexiographically ordered which\n * makes this a nice feature for databases.\n *\n * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeTerminatedString = (encoder, str) =>\n  writeTerminatedUint8Array(encoder, string.encodeUtf8(str))\n\n/**\n * Write a terminating Uint8Array. Note that this is not performant and is generally\n * discouraged. There are few situations when this is needed.\n *\n * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.\n *\n * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then\n * the result is terminated using the 0x0 character.\n *\n * This is basically how many systems implement null terminated strings. However, we use an escape\n * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key\n * encoder for NoSql databases).\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} buf The string that is to be encoded.\n */\nexport const writeTerminatedUint8Array = (encoder, buf) => {\n  for (let i = 0; i < buf.length; i++) {\n    const b = buf[i]\n    if (b === 0 || b === 1) {\n      write(encoder, 1)\n    }\n    write(encoder, buf[i])\n  }\n  write(encoder, 0)\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (array.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n", "/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nexport const create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n", "/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as binary from './binary.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as string from './string.js'\nimport * as error from './error.js'\nimport * as encoding from './encoding.js'\n\nconst errorUnexpectedEndOfArray = error.create('Unexpected end of array')\nconst errorIntegerOutOfRange = error.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let mult = 64\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult\n    mult *= 128\n    if (r < binary.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder =>\n  /** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTerminatedUint8Array = decoder => {\n  const encoder = encoding.createEncoder()\n  let b\n  while (true) {\n    b = readUint8(decoder)\n    if (b === 0) {\n      return encoding.toUint8Array(encoder)\n    }\n    if (b === 1) {\n      b = readUint8(decoder)\n    }\n    encoding.write(encoder, b)\n  }\n}\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const readTerminatedString = decoder => string.decodeUtf8(readTerminatedUint8Array(decoder))\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = math.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n", "import * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\n\nenum AuthMessageType {\n  Token = 0,\n  PermissionDenied = 1,\n  Authenticated = 2,\n}\n\nexport const writeAuthentication = (encoder: encoding.Encoder, auth: string) => {\n  encoding.writeVarUint(encoder, AuthMessageType.Token)\n  encoding.writeVarString(encoder, auth)\n}\n\nexport const writePermissionDenied = (encoder: encoding.Encoder, reason: string) => {\n  encoding.writeVarUint(encoder, AuthMessageType.PermissionDenied)\n  encoding.writeVarString(encoder, reason)\n}\n\nexport const writeAuthenticated = (encoder: encoding.Encoder, scope: 'readonly' | 'read-write') => {\n  encoding.writeVarUint(encoder, AuthMessageType.Authenticated)\n  encoding.writeVarString(encoder, scope)\n}\n\nexport const readAuthMessage = (\n  decoder: decoding.Decoder,\n  permissionDeniedHandler: (reason: string) => void,\n  authenticatedHandler: (scope: string) => void,\n) => {\n  switch (decoding.readVarUint(decoder)) {\n    case AuthMessageType.PermissionDenied: {\n      permissionDeniedHandler(decoding.readVarString(decoder))\n      break\n    }\n    case AuthMessageType.Authenticated: {\n      authenticatedHandler(decoding.readVarString(decoder))\n      break\n    }\n    default:\n  }\n}\n", "export interface CloseEvent {\n  code: number,\n  reason: string,\n}\n\n/**\n * The server is terminating the connection because a data frame was received\n * that is too large.\n * See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\n */\nexport const MessageTooBig: CloseEvent = {\n  code: 1009,\n  reason: 'Message Too Big',\n}\n\n/**\n * The server successfully processed the request, asks that the requester reset\n * its document view, and is not returning any content.\n */\nexport const ResetConnection: CloseEvent = {\n  code: 4205,\n  reason: 'Reset Connection',\n}\n\n/**\n * Similar to Forbidden, but specifically for use when authentication is required and has\n * failed or has not yet been provided.\n */\nexport const Unauthorized: CloseEvent = {\n  code: 4401,\n  reason: 'Unauthorized',\n}\n\n/**\n * The request contained valid data and was understood by the server, but the server\n * is refusing action.\n */\nexport const Forbidden: CloseEvent = {\n  code: 4403,\n  reason: 'Forbidden',\n}\n\n/**\n * The server timed out waiting for the request.\n */\nexport const ConnectionTimeout: CloseEvent = {\n  code: 4408,\n  reason: 'Connection Timeout',\n}\n", "export const awarenessStatesToArray = (states: Map<number, Record<string, any>>) => {\n  return Array.from(states.entries()).map(([key, value]) => {\n    return {\n      clientId: key,\n      ...value,\n    }\n  })\n}\n", "/**\n * State of the WebSocket connection.\n * https://developer.mozilla.org/de/docs/Web/API/WebSocket/readyState\n */\nexport enum WsReadyStates {\n  Connecting = 0,\n  Open = 1,\n  Closing = 2,\n  Closed = 3,\n}\n", "function applyDefaults(options) {\n    if (!options) {\n        options = {};\n    }\n    return {\n        delay: (options.delay === undefined) ? 200 : options.delay,\n        initialDelay: (options.initialDelay === undefined) ? 0 : options.initialDelay,\n        minDelay: (options.minDelay === undefined) ? 0 : options.minDelay,\n        maxDelay: (options.maxDelay === undefined) ? 0 : options.maxDelay,\n        factor: (options.factor === undefined) ? 0 : options.factor,\n        maxAttempts: (options.maxAttempts === undefined) ? 3 : options.maxAttempts,\n        timeout: (options.timeout === undefined) ? 0 : options.timeout,\n        jitter: (options.jitter === true),\n        initialJitter: (options.initialJitter === true),\n        handleError: (options.handleError === undefined) ? null : options.handleError,\n        handleTimeout: (options.handleTimeout === undefined) ? null : options.handleTimeout,\n        beforeAttempt: (options.beforeAttempt === undefined) ? null : options.beforeAttempt,\n        calculateDelay: (options.calculateDelay === undefined) ? null : options.calculateDelay\n    };\n}\nexport async function sleep(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\nexport function defaultCalculateDelay(context, options) {\n    let delay = options.delay;\n    if (delay === 0) {\n        // no delay between attempts\n        return 0;\n    }\n    if (options.factor) {\n        delay *= Math.pow(options.factor, context.attemptNum - 1);\n        if (options.maxDelay !== 0) {\n            delay = Math.min(delay, options.maxDelay);\n        }\n    }\n    if (options.jitter) {\n        // Jitter will result in a random value between `minDelay` and\n        // calculated delay for a given attempt.\n        // See https://www.awsarchitectureblog.com/2015/03/backoff.html\n        // We're using the \"full jitter\" strategy.\n        const min = Math.ceil(options.minDelay);\n        const max = Math.floor(delay);\n        delay = Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.round(delay);\n}\nexport async function retry(attemptFunc, attemptOptions) {\n    const options = applyDefaults(attemptOptions);\n    for (const prop of [\n        'delay',\n        'initialDelay',\n        'minDelay',\n        'maxDelay',\n        'maxAttempts',\n        'timeout'\n    ]) {\n        const value = options[prop];\n        if (!Number.isInteger(value) || (value < 0)) {\n            throw new Error(`Value for ${prop} must be an integer greater than or equal to 0`);\n        }\n    }\n    if ((options.factor.constructor !== Number) || (options.factor < 0)) {\n        throw new Error(`Value for factor must be a number greater than or equal to 0`);\n    }\n    if (options.delay < options.minDelay) {\n        throw new Error(`delay cannot be less than minDelay (delay: ${options.delay}, minDelay: ${options.minDelay}`);\n    }\n    const context = {\n        attemptNum: 0,\n        attemptsRemaining: options.maxAttempts ? options.maxAttempts : -1,\n        aborted: false,\n        abort() {\n            context.aborted = true;\n        }\n    };\n    const calculateDelay = options.calculateDelay || defaultCalculateDelay;\n    async function makeAttempt() {\n        if (options.beforeAttempt) {\n            options.beforeAttempt(context, options);\n        }\n        if (context.aborted) {\n            const err = new Error(`Attempt aborted`);\n            err.code = 'ATTEMPT_ABORTED';\n            throw err;\n        }\n        const onError = async (err) => {\n            if (options.handleError) {\n                await options.handleError(err, context, options);\n            }\n            if (context.aborted || (context.attemptsRemaining === 0)) {\n                throw err;\n            }\n            // We are about to try again so increment attempt number\n            context.attemptNum++;\n            const delay = calculateDelay(context, options);\n            if (delay) {\n                await sleep(delay);\n            }\n            return makeAttempt();\n        };\n        if (context.attemptsRemaining > 0) {\n            context.attemptsRemaining--;\n        }\n        if (options.timeout) {\n            return new Promise((resolve, reject) => {\n                const timer = setTimeout(() => {\n                    if (options.handleTimeout) {\n                        // If calling handleTimeout throws an error that is not wrapped in a promise\n                        // we want to catch the error and reject.\n                        try {\n                            resolve(options.handleTimeout(context, options));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    }\n                    else {\n                        const err = new Error(`Retry timeout (attemptNum: ${context.attemptNum}, timeout: ${options.timeout})`);\n                        err.code = 'ATTEMPT_TIMEOUT';\n                        reject(err);\n                    }\n                }, options.timeout);\n                attemptFunc(context, options).then((result) => {\n                    clearTimeout(timer);\n                    resolve(result);\n                }).catch((err) => {\n                    clearTimeout(timer);\n                    // Calling resolve with a Promise that rejects here will result\n                    // in an unhandled rejection. Calling `reject` with errors\n                    // does not result in an unhandled rejection\n                    onError(err).then(resolve).catch(reject);\n                });\n            });\n        }\n        else {\n            // No timeout provided so wait indefinitely for the returned promise\n            // to be resolved.\n            return attemptFunc(context, options).catch(onError);\n        }\n    }\n    const initialDelay = options.calculateDelay\n        ? options.calculateDelay(context, options)\n        : options.initialDelay;\n    if (initialDelay) {\n        await sleep(initialDelay);\n    }\n    if (context.attemptNum < 1 && options.initialJitter) {\n        const delay = calculateDelay(context, options);\n        if (delay) {\n            await sleep(delay);\n        }\n    }\n    return makeAttempt();\n}\n", "/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template V,K\n * @template {Map<K,V>} MAP\n * @param {MAP} map\n * @param {K} key\n * @param {function():V} createT\n * @return {V}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n", "/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nexport const first = set =>\n  set.values().next().value || undefined\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n", "/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n * @template {ArrayLike<ITEM>} ARR\n *\n * @param {ARR} arr\n * @param {function(ITEM, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @template {ArrayLike<S>} ARR\n * @param {ARR} arr\n * @param {function(S, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n", "import * as array from './array.js'\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * The largest utf16 character.\n * Corresponds to Uint8Array([255, 255]) or charcodeof(2x2^8)\n */\nexport const MAX_UTF16_CHARACTER = fromCharCode(65535)\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* c8 ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* c8 ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* c8 ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nexport const splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n\n/**\n * @param {string} source\n * @param {number} n\n */\nexport const repeat = (source, n) => array.unfold(n, () => source).join('')\n", "/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* c8 ignore next */\nexport const undefinedToNull = v => v === undefined ? null : v\n", "/* eslint-env browser */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* c8 ignore start */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\n/* c8 ignore start */\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  if (typeof localStorage !== 'undefined' && localStorage) {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n/* c8 ignore stop */\n\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\n/* c8 ignore next */\nexport const varStorage = _localStorage\n\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nexport const onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n\n/**\n * A polyfill for `removeEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nexport const offChange = eventHandler => usePolyfill || removeEventListener('storage', /** @type {any} */ (eventHandler))\n", "/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @template V\n * @param {{[k:string]:V}} obj\n * @param {function(V,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object|undefined} obj\n */\nexport const isEmpty = obj => {\n  // eslint-disable-next-line\n  for (const _k in obj) {\n    return false\n  }\n  return true\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n", "/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((array.isArray(a) && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nexport const isOneOf = (value, options) => options.includes(value)\n/* c8 ignore stop */\n\nexport const isArray = array.isArray\n\n/**\n * @param {any} s\n * @return {s is String}\n */\nexport const isString = (s) => s && s.constructor === String\n\n/**\n * @param {any} n\n * @return {n is Number}\n */\nexport const isNumber = n => n != null && n.constructor === Number\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {any} n\n * @param {TYPE} T\n * @return {n is InstanceType<TYPE>}\n */\nexport const is = (n, T) => n && n.constructor === T\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {TYPE} T\n */\nexport const isTemplate = (T) =>\n  /**\n   * @param {any} n\n   * @return {n is InstanceType<TYPE>}\n   **/\n  n => n && n.constructor === T\n", "/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\nimport * as map from './map.js'\nimport * as string from './string.js'\nimport * as conditions from './conditions.js'\nimport * as storage from './storage.js'\nimport * as f from './function.js'\n\n/* c8 ignore next 2 */\n// @ts-ignore\nexport const isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n\n/* c8 ignore next */\nexport const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !isNode\n/* c8 ignore next 3 */\nexport const isMac = typeof navigator !== 'undefined'\n  ? /Mac/.test(navigator.platform)\n  : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* c8 ignore start */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = map.create()\n      const pargs = process.argv\n      let currParamName = null\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n      // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = map.create(); // eslint-disable-next-line no-undef\n      (location.search || '?').slice(1).split('&').forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${string.fromCamelCase(key, '-')}`, value)\n          params.set(`-${string.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = map.create()\n    }\n  }\n  return params\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next */\nexport const hasParam = (name) => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* c8 ignore next 2 */\nexport const getParam = (name, defaultVal) =>\n  computeParams().get(name) || defaultVal\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 4 */\nexport const getVariable = (name) =>\n  isNode\n    ? conditions.undefinedToNull(process.env[name.toUpperCase()])\n    : conditions.undefinedToNull(storage.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 2 */\nexport const getConf = (name) =>\n  computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next 2 */\nexport const hasConf = (name) =>\n  hasParam('--' + name) || getVariable(name) !== null\n\n/* c8 ignore next */\nexport const production = hasConf('production')\n\n/* c8 ignore next 2 */\nconst forceColor = isNode &&\n  f.isOneOf(process.env.FORCE_COLOR, ['true', '1', '2'])\n\n/* c8 ignore start */\nexport const supportsColor = !hasParam('no-colors') &&\n  (!isNode || process.stdout.isTTY || forceColor) && (\n  !isNode || hasParam('color') || forceColor ||\n    getVariable('COLORTERM') !== null ||\n    (getVariable('TERM') || '').includes('color')\n)\n/* c8 ignore stop */\n", "/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n", "/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n", "/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\nexport const HIGHEST_INT32 = binary.BITS31\nexport const HIGHEST_UINT32 = binary.BITS32\n\n/* c8 ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\nexport const parseInt = Number.parseInt\n\n/**\n * Count the number of \"1\" bits in an unsigned 32bit number.\n *\n * Super fun bitcount algorithm by Brian Kernighan.\n *\n * @param {number} n\n */\nexport const countBits = n => {\n  n &= binary.BITS32\n  let count = 0\n  while (n) {\n    n &= (n - 1)\n    count++\n  }\n  return count\n}\n", "/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\nimport * as string from './string.js'\nimport * as array from './array.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * @param {function(Encoder):void} f\n */\nexport const encode = (f) => {\n  const encoder = createEncoder()\n  f(encoder)\n  return toUint8Array(encoder)\n}\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nexport const hasContent = encoder => encoder.cpos > 0 || encoder.bufs.length > 0\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nexport const verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num = math.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, string.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nexport const writeVarString = (string.utf8TextEncoder && /** @type {any} */ (string.utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write a string terminated by a special byte sequence. This is not very performant and is\n * generally discouraged. However, the resulting byte arrays are lexiographically ordered which\n * makes this a nice feature for databases.\n *\n * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeTerminatedString = (encoder, str) =>\n  writeTerminatedUint8Array(encoder, string.encodeUtf8(str))\n\n/**\n * Write a terminating Uint8Array. Note that this is not performant and is generally\n * discouraged. There are few situations when this is needed.\n *\n * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.\n *\n * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then\n * the result is terminated using the 0x0 character.\n *\n * This is basically how many systems implement null terminated strings. However, we use an escape\n * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key\n * encoder for NoSql databases).\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} buf The string that is to be encoded.\n */\nexport const writeTerminatedUint8Array = (encoder, buf) => {\n  for (let i = 0; i < buf.length; i++) {\n    const b = buf[i]\n    if (b === 0 || b === 1) {\n      write(encoder, 1)\n    }\n    write(encoder, buf[i])\n  }\n  write(encoder, 0)\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (array.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n", "/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nexport const create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n", "/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as binary from './binary.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as string from './string.js'\nimport * as error from './error.js'\nimport * as encoding from './encoding.js'\n\nconst errorUnexpectedEndOfArray = error.create('Unexpected end of array')\nconst errorIntegerOutOfRange = error.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let mult = 64\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult\n    mult *= 128\n    if (r < binary.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder =>\n  /** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTerminatedUint8Array = decoder => {\n  const encoder = encoding.createEncoder()\n  let b\n  while (true) {\n    b = readUint8(decoder)\n    if (b === 0) {\n      return encoding.toUint8Array(encoder)\n    }\n    if (b === 1) {\n      b = readUint8(decoder)\n    }\n    encoding.write(encoder, b)\n  }\n}\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const readTerminatedString = decoder => string.decodeUtf8(readTerminatedUint8Array(decoder))\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = math.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n", "/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\nimport * as string from './string.js'\nimport * as env from './environment.js'\nimport * as array from './array.js'\nimport * as math from './math.js'\nimport * as encoding from './encoding.js'\nimport * as decoding from './decoding.js'\n\n/**\n * @param {number} len\n */\nexport const createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nexport const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nexport const createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* c8 ignore start */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* c8 ignore start */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* c8 ignore next */\nexport const toBase64 = env.isBrowser ? toBase64Browser : toBase64Node\n\n/* c8 ignore next */\nexport const fromBase64 = env.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Implements base64url - see https://datatracker.ietf.org/doc/html/rfc4648#section-5\n * @param {Uint8Array} buf\n */\nexport const toBase64UrlEncoded = buf => toBase64(buf).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '')\n\n/**\n * @param {string} base64\n */\nexport const fromBase64UrlEncoded = base64 => fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'))\n\n/**\n * Base64 is always a more efficient choice. This exists for utility purposes only.\n *\n * @param {Uint8Array} buf\n */\nexport const toHexString = buf => array.map(buf, b => b.toString(16).padStart(2, '0')).join('')\n\n/**\n * Note: This function expects that the hex doesn't start with 0x..\n *\n * @param {string} hex\n */\nexport const fromHexString = hex => {\n  const hlen = hex.length\n  const buf = new Uint8Array(math.ceil(hlen / 2))\n  for (let i = 0; i < hlen; i += 2) {\n    buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16)\n  }\n  return buf\n}\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nexport const copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nexport const encodeAny = data =>\n  encoding.encode(encoder => encoding.writeAny(encoder, data))\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nexport const decodeAny = buf => decoding.readAny(decoding.createDecoder(buf))\n\n/**\n * Shift Byte Array {N} bits to the left. Does not expand byte array.\n *\n * @param {Uint8Array} bs\n * @param {number} N should be in the range of [0-7]\n */\nexport const shiftNBitsLeft = (bs, N) => {\n  if (N === 0) return bs\n  bs = new Uint8Array(bs)\n  bs[0] <<= N\n  for (let i = 1; i < bs.length; i++) {\n    bs[i - 1] |= bs[i] >>> (8 - N)\n    bs[i] <<= N\n  }\n  return bs\n}\n", "/* eslint-env browser */\n\n/**\n * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.\n *\n * ```js\n * // In browser window A:\n * broadcastchannel.subscribe('my events', data => console.log(data))\n * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab\n *\n * // In browser window B:\n * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'\n * ```\n *\n * @module broadcastchannel\n */\n\n// @todo before next major: use Uint8Array instead as buffer object\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as buffer from './buffer.js'\nimport * as storage from './storage.js'\n\n/**\n * @typedef {Object} Channel\n * @property {Set<function(any, any):any>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map()\n\n/* c8 ignore start */\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null\n    /**\n     * @param {any} e\n     */\n    this._onChange = e => e.key === room && this.onmessage !== null && this.onmessage({ data: buffer.fromBase64(e.newValue || '') })\n    storage.onChange(this._onChange)\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    storage.varStorage.setItem(this.room, buffer.toBase64(buffer.createUint8ArrayFromArrayBuffer(buf)))\n  }\n\n  close () {\n    storage.offChange(this._onChange)\n  }\n}\n/* c8 ignore stop */\n\n// Use BroadcastChannel or Polyfill\n/* c8 ignore next */\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  map.setIfUndefined(channels, room, () => {\n    const subs = set.create()\n    const bc = new BC(room)\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    /* c8 ignore next */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data, 'broadcastchannel'))\n    return {\n      bc, subs\n    }\n  })\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nexport const subscribe = (room, f) => {\n  getChannel(room).subs.add(f)\n  return f\n}\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nexport const unsubscribe = (room, f) => {\n  const channel = getChannel(room)\n  const unsubscribed = channel.subs.delete(f)\n  if (unsubscribed && channel.subs.size === 0) {\n    channel.bc.close()\n    channels.delete(room)\n  }\n  return unsubscribed\n}\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n * @param {any} [origin]\n */\nexport const publish = (room, data, origin = null) => {\n  const c = getChannel(room)\n  c.bc.postMessage(data)\n  c.subs.forEach(sub => sub(data, origin))\n}\n", "/**\n * Mutual exclude for JavaScript.\n *\n * @module mutex\n */\n\n/**\n * @callback mutex\n * @param {function():void} cb Only executed when this mutex is not in the current stack\n * @param {function():void} [elseCb] Executed when this mutex is in the current stack\n */\n\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n *\n * @return {mutex} A mutual exclude function\n * @public\n */\nexport const createMutex = () => {\n  let token = true\n  return (f, g) => {\n    if (token) {\n      token = false\n      try {\n        f()\n      } finally {\n        token = true\n      }\n    } else if (g !== undefined) {\n      g()\n    }\n  }\n}\n", "/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10μs.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* c8 ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n", "/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n", "/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n", "export default class EventEmitter {\n\n  public callbacks: { [key: string]: Function[] } = {}\n\n  public on(event: string, fn: Function): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit(event: string, ...args: any): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off(event: string, fn?: Function): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n", "/**\n * Utility module to work with urls.\n *\n * @module url\n */\n\nimport * as object from './object.js'\n\n/**\n * Parse query parameters from an url.\n *\n * @param {string} url\n * @return {Object<string,string>}\n */\nexport const decodeQueryParams = url => {\n  /**\n   * @type {Object<string,string>}\n   */\n  const query = {}\n  const urlQuerySplit = url.split('?')\n  const pairs = urlQuerySplit[urlQuerySplit.length - 1].split('&')\n  for (let i = 0; i < pairs.length; i++) {\n    const item = pairs[i]\n    if (item.length > 0) {\n      const pair = item.split('=')\n      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')\n    }\n  }\n  return query\n}\n\n/**\n * @param {Object<string,string>} params\n * @return {string}\n */\nexport const encodeQueryParams = params =>\n  object.map(params, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&')\n", "import { Encoder } from 'lib0/encoding'\nimport type { Event, MessageEvent } from 'ws'\nimport { Awareness } from 'y-protocols/awareness'\nimport * as Y from 'yjs'\nimport { CloseEvent } from '@hocuspocus/common'\nimport { IncomingMessage } from './IncomingMessage.js'\nimport { OutgoingMessage } from './OutgoingMessage.js'\nimport { AuthenticationMessage } from './OutgoingMessages/AuthenticationMessage.js'\nimport { AwarenessMessage } from './OutgoingMessages/AwarenessMessage.js'\nimport { QueryAwarenessMessage } from './OutgoingMessages/QueryAwarenessMessage.js'\nimport { SyncStepOneMessage } from './OutgoingMessages/SyncStepOneMessage.js'\nimport { SyncStepTwoMessage } from './OutgoingMessages/SyncStepTwoMessage.js'\nimport { UpdateMessage } from './OutgoingMessages/UpdateMessage.js'\n\nexport enum MessageType {\n  Sync = 0,\n  Awareness = 1,\n  Auth = 2,\n  QueryAwareness = 3,\n  Stateless = 5,\n  CLOSE = 7,\n  SyncStatus = 8,\n}\n\nexport enum WebSocketStatus {\n  Connecting = 'connecting',\n  Connected = 'connected',\n  Disconnected = 'disconnected',\n}\n\nexport interface OutgoingMessageInterface {\n  encoder: Encoder\n  type?: MessageType\n}\n\nexport interface OutgoingMessageArguments {\n  documentName: string,\n  token: string,\n  document: Y.Doc,\n  awareness: Awareness,\n  clients: number[],\n  states: Map<number, { [key: string]: any; }>,\n  update: any,\n  payload: string,\n  encoder: Encoder,\n}\n\nexport interface Constructable<T> {\n  new(...args: any) : T\n}\n\nexport type ConstructableOutgoingMessage =\n  Constructable<AuthenticationMessage> |\n  Constructable<AwarenessMessage> |\n  Constructable<QueryAwarenessMessage> |\n  Constructable<SyncStepOneMessage> |\n  Constructable<SyncStepTwoMessage> |\n  Constructable<UpdateMessage>\n\nexport type onAuthenticationFailedParameters = {\n  reason: string,\n}\n\nexport type onOpenParameters = {\n  event: Event,\n}\n\nexport type onMessageParameters = {\n  event: MessageEvent,\n  message: IncomingMessage,\n}\n\nexport type onOutgoingMessageParameters = {\n  message: OutgoingMessage,\n}\n\nexport type onStatusParameters = {\n  status: WebSocketStatus,\n}\n\nexport type onSyncedParameters = {\n  state: boolean,\n}\n\nexport type onDisconnectParameters = {\n  event: CloseEvent,\n}\n\nexport type onCloseParameters = {\n  event: CloseEvent,\n}\n\nexport type onAwarenessUpdateParameters = {\n  states: StatesArray\n}\n\nexport type onAwarenessChangeParameters = {\n  states: StatesArray\n}\n\nexport type onStatelessParameters = {\n  payload: string\n}\n\nexport type StatesArray = { clientId: number, [key: string | number]: any }[]\n\n// hocuspocus-pro types\n\nexport type TCollabThread<Data = any, CommentData = any> = {\n  id: string;\n  createdAt: number;\n  updatedAt: number;\n  deletedAt: number | null;\n  resolvedAt?: string; // (new Date()).toISOString()\n  comments: TCollabComment<CommentData>[];\n  deletedComments: TCollabComment<CommentData>[];\n  data: Data\n}\n\nexport type TCollabComment<Data = any> = {\n  id: string;\n  createdAt: string;\n  updatedAt: string;\n  deletedAt?: string;\n  data: Data\n  content: any\n}\n\nexport type THistoryVersion = {\n  name?: string;\n  version: number;\n  date: number;\n};\n\nexport type THistoryConfiguration = {\n  autoVersioning: boolean;\n  currentVersion: number;\n  stateCaptured: number; // indicates whether changes have been made since the last version\n};\n\nexport type THistoryAction =\n  | THistoryDocumentRevertAction\n  | THistoryVersionCreateAction\n  | THistoryVersionPreviewAction;\n\nexport type THistoryDocumentRevertAction = {\n  action: 'document.revert';\n  /**\n   * if changes haven't been persisted to a version yet, we'll create one with the specified name,\n   * expect when `false` is passed.\n   */\n  currentVersionName?: string | false;\n  /**\n   * Name of the version that is created after the revert. Pass `false` to avoid generating a new version.\n   */\n  newVersionName?: string | false;\n};\n\nexport type THistoryVersionCreateAction = {\n  action: 'version.create';\n  name?: string;\n};\n\nexport type THistoryVersionPreviewAction = {\n  action: 'version.preview';\n  version: number;\n};\n\nexport type THistoryEvent =\n  | THistoryVersionPreviewEvent\n  | THistoryVersionCreatedEvent\n  | THistoryDocumentRevertedEvent;\n\nexport type THistoryVersionCreatedEvent = {\n  event: 'version.created';\n  version: number;\n};\n\nexport type THistoryVersionPreviewEvent = {\n  event: 'version.preview';\n  version: number;\n  ydoc: string; // base64-encoded Uint8Array\n};\n\nexport type THistoryDocumentRevertedEvent = {\n  event: 'document.reverted';\n  version: number;\n};\n\nexport type DeleteCommentOptions = {\n  /**\n   * If `true`, the thread will also be deleted if the deleted comment was the first comment in the thread.\n   */\n  deleteThread?: boolean\n\n  /**\n   * If `true`, will remove the content of the deleted comment\n   */\n  deleteContent?: boolean\n}\n\nexport type DeleteThreadOptions = {\n  /**\n   * If `true`, will remove the comments on the thread,\n   * otherwise will only mark the thread as deleted\n   * and keep the comments\n   * @default false\n   */\n  deleteComments?: boolean\n\n  /**\n   * If `true`, will forcefully remove the thread and all comments,\n   * otherwise will only mark the thread as deleted\n   * and keep the comments\n   * @default false\n   */\n  force?: boolean,\n}\n\n/**\n * The type of thread\n */\nexport type ThreadType = 'archived' | 'unarchived'\n\nexport type GetThreadsOptions = {\n  /**\n   * The types of threads to get\n   * @default ['unarchived']\n   */\n  types?: Array<ThreadType>\n}\n", "import {\n  createDecoder,\n  peekVarString,\n  readVarUint,\n  readVarUint8Array,\n  readVarString,\n  Decoder,\n} from 'lib0/decoding'\nimport {\n  Encoder,\n  createEncoder,\n  writeVarUint,\n  writeVarUint8Array,\n  writeVarString,\n  length,\n} from 'lib0/encoding'\nimport { MessageType } from './types.js'\n\nexport class IncomingMessage {\n\n  data: any\n\n  encoder: Encoder\n\n  decoder: Decoder\n\n  constructor(data: any) {\n    this.data = data\n    this.encoder = createEncoder()\n    this.decoder = createDecoder(new Uint8Array(this.data))\n  }\n\n  peekVarString(): string {\n    return peekVarString(this.decoder)\n  }\n\n  readVarUint(): MessageType {\n    return readVarUint(this.decoder)\n  }\n\n  readVarString(): string {\n    return readVarString(this.decoder)\n  }\n\n  readVarUint8Array() {\n    return readVarUint8Array(this.decoder)\n  }\n\n  writeVarUint(type: MessageType) {\n    return writeVarUint(this.encoder, type)\n  }\n\n  writeVarString(string: string) {\n    return writeVarString(this.encoder, string)\n  }\n\n  writeVarUint8Array(data: Uint8Array) {\n    return writeVarUint8Array(this.encoder, data)\n  }\n\n  length() {\n    return length(this.encoder)\n  }\n}\n", "import {\n  Forbidden, MessageTooBig, Unauthorized, WsReadyStates,\n} from '@hocuspocus/common'\nimport { retry } from '@lifeomic/attempt'\nimport * as time from 'lib0/time'\nimport * as url from 'lib0/url'\nimport type { MessageEvent } from 'ws'\nimport { Event } from 'ws'\nimport EventEmitter from './EventEmitter.js'\nimport { HocuspocusProvider } from './HocuspocusProvider.js'\nimport {\n  WebSocketStatus,\n  onAwarenessChangeParameters, onAwarenessUpdateParameters,\n  onCloseParameters, onDisconnectParameters, onMessageParameters, onOpenParameters, onOutgoingMessageParameters, onStatusParameters,\n} from './types.js'\nimport { IncomingMessage } from './IncomingMessage.js'\n\nexport type HocusPocusWebSocket = WebSocket & { identifier: string };\n\nexport type HocuspocusProviderWebsocketConfiguration =\n  Required<Pick<CompleteHocuspocusProviderWebsocketConfiguration, 'url'>>\n  & Partial<CompleteHocuspocusProviderWebsocketConfiguration>\n\nexport interface CompleteHocuspocusProviderWebsocketConfiguration {\n  /**\n   * URL of your @hocuspocus/server instance\n   */\n   url: string,\n\n  /**\n   * Pass `false` to start the connection manually.\n   */\n  connect: boolean,\n\n  /**\n   * URL parameters that should be added.\n   */\n  parameters: { [key: string]: any },\n  /**\n   * An optional WebSocket polyfill, for example for Node.js\n   */\n  WebSocketPolyfill: any,\n\n  /**\n   * Disconnect when no message is received for the defined amount of milliseconds.\n   */\n  messageReconnectTimeout: number,\n  /**\n   * The delay between each attempt in milliseconds. You can provide a factor to have the delay grow exponentially.\n   */\n  delay: number,\n  /**\n   * The initialDelay is the amount of time to wait before making the first attempt. This option should typically be 0 since you typically want the first attempt to happen immediately.\n   */\n  initialDelay: number,\n  /**\n   * The factor option is used to grow the delay exponentially.\n   */\n  factor: number,\n  /**\n   * The maximum number of attempts or 0 if there is no limit on number of attempts.\n   */\n  maxAttempts: number,\n  /**\n   * minDelay is used to set a lower bound of delay when jitter is enabled. This property has no effect if jitter is disabled.\n   */\n  minDelay: number,\n  /**\n   * The maxDelay option is used to set an upper bound for the delay when factor is enabled. A value of 0 can be provided if there should be no upper bound when calculating delay.\n   */\n  maxDelay: number,\n  /**\n   * If jitter is true then the calculated delay will be a random integer value between minDelay and the calculated delay for the current iteration.\n   */\n  jitter: boolean,\n  /**\n   * A timeout in milliseconds. If timeout is non-zero then a timer is set using setTimeout. If the timeout is triggered then future attempts will be aborted.\n   */\n  timeout: number,\n  onOpen: (data: onOpenParameters) => void,\n  onConnect: () => void,\n  onMessage: (data: onMessageParameters) => void,\n  onOutgoingMessage: (data: onOutgoingMessageParameters) => void,\n  onStatus: (data: onStatusParameters) => void,\n  onDisconnect: (data: onDisconnectParameters) => void,\n  onClose: (data: onCloseParameters) => void,\n  onDestroy: () => void,\n  onAwarenessUpdate: (data: onAwarenessUpdateParameters) => void,\n  onAwarenessChange: (data: onAwarenessChangeParameters) => void,\n  /**\n   * Don’t output any warnings.\n   */\n  quiet: boolean,\n\n  /**\n   * Map of attached providers keyed by documentName.\n   */\n  providerMap: Map<string, HocuspocusProvider>,\n}\n\nexport class HocuspocusProviderWebsocket extends EventEmitter {\n  private messageQueue: any[] = []\n\n  public configuration: CompleteHocuspocusProviderWebsocketConfiguration = {\n    url: '',\n    // @ts-ignore\n    document: undefined,\n    WebSocketPolyfill: undefined,\n    parameters: {},\n    connect: true,\n    broadcast: true,\n    forceSyncInterval: false,\n    // TODO: this should depend on awareness.outdatedTime\n    messageReconnectTimeout: 30000,\n    // 1 second\n    delay: 1000,\n    // instant\n    initialDelay: 0,\n    // double the delay each time\n    factor: 2,\n    // unlimited retries\n    maxAttempts: 0,\n    // wait at least 1 second\n    minDelay: 1000,\n    // at least every 30 seconds\n    maxDelay: 30000,\n    // randomize\n    jitter: true,\n    // retry forever\n    timeout: 0,\n    onOpen: () => null,\n    onConnect: () => null,\n    onMessage: () => null,\n    onOutgoingMessage: () => null,\n    onStatus: () => null,\n    onDisconnect: () => null,\n    onClose: () => null,\n    onDestroy: () => null,\n    onAwarenessUpdate: () => null,\n    onAwarenessChange: () => null,\n    quiet: false,\n    providerMap: new Map(),\n  }\n\n  webSocket: HocusPocusWebSocket | null = null\n\n  webSocketHandlers: { [key: string]: any } = {}\n\n  shouldConnect = true\n\n  status = WebSocketStatus.Disconnected\n\n  lastMessageReceived = 0\n\n  identifier = 0\n\n  intervals: any = {\n    forceSync: null,\n    connectionChecker: null,\n  }\n\n  connectionAttempt: {\n    resolve: (value?: any) => void;\n    reject: (reason?: any) => void;\n  } | null = null\n\n  constructor(configuration: HocuspocusProviderWebsocketConfiguration) {\n    super()\n    this.setConfiguration(configuration)\n\n    this.configuration.WebSocketPolyfill = configuration.WebSocketPolyfill\n      ? configuration.WebSocketPolyfill\n      : WebSocket\n\n    this.on('open', this.configuration.onOpen)\n    this.on('open', this.onOpen.bind(this))\n    this.on('connect', this.configuration.onConnect)\n    this.on('message', this.configuration.onMessage)\n    this.on('outgoingMessage', this.configuration.onOutgoingMessage)\n    this.on('status', this.configuration.onStatus)\n    this.on('status', this.onStatus.bind(this))\n    this.on('disconnect', this.configuration.onDisconnect)\n    this.on('close', this.configuration.onClose)\n    this.on('destroy', this.configuration.onDestroy)\n    this.on('awarenessUpdate', this.configuration.onAwarenessUpdate)\n    this.on('awarenessChange', this.configuration.onAwarenessChange)\n\n    this.on('close', this.onClose.bind(this))\n    this.on('message', this.onMessage.bind(this))\n\n    this.intervals.connectionChecker = setInterval(\n      this.checkConnection.bind(this),\n      this.configuration.messageReconnectTimeout / 10,\n    )\n\n    if (typeof configuration.connect !== 'undefined') {\n      this.shouldConnect = configuration.connect\n    }\n\n    if (!this.shouldConnect) {\n      return\n    }\n\n    this.connect()\n  }\n\n  receivedOnOpenPayload?: Event | undefined = undefined\n\n  receivedOnStatusPayload?: onStatusParameters | undefined = undefined\n\n  async onOpen(event: Event) {\n    this.receivedOnOpenPayload = event\n  }\n\n  async onStatus(data: onStatusParameters) {\n    this.receivedOnStatusPayload = data\n  }\n\n  attach(provider: HocuspocusProvider) {\n    let connectPromise: Promise<any> | undefined\n    this.configuration.providerMap.set(provider.configuration.name, provider)\n\n    if (this.status === WebSocketStatus.Disconnected && this.shouldConnect) {\n      connectPromise = this.connect()\n    }\n\n    if (this.receivedOnOpenPayload) {\n      provider.onOpen(this.receivedOnOpenPayload)\n    }\n\n    if (this.receivedOnStatusPayload) {\n      provider.onStatus(this.receivedOnStatusPayload)\n    }\n\n    return connectPromise\n  }\n\n  detach(provider: HocuspocusProvider) {\n    this.configuration.providerMap.delete(provider.configuration.name)\n  }\n\n  public setConfiguration(\n    configuration: Partial<HocuspocusProviderWebsocketConfiguration> = {},\n  ): void {\n    this.configuration = { ...this.configuration, ...configuration }\n  }\n\n  cancelWebsocketRetry?: () => void\n\n  async connect() {\n    if (this.status === WebSocketStatus.Connected) {\n      return\n    }\n\n    // Always cancel any previously initiated connection retryer instances\n    if (this.cancelWebsocketRetry) {\n      this.cancelWebsocketRetry()\n      this.cancelWebsocketRetry = undefined\n    }\n\n    this.receivedOnOpenPayload = undefined\n    this.receivedOnStatusPayload = undefined\n    this.shouldConnect = true\n\n    const abortableRetry = () => {\n      let cancelAttempt = false\n\n      const retryPromise = retry(this.createWebSocketConnection.bind(this), {\n        delay: this.configuration.delay,\n        initialDelay: this.configuration.initialDelay,\n        factor: this.configuration.factor,\n        maxAttempts: this.configuration.maxAttempts,\n        minDelay: this.configuration.minDelay,\n        maxDelay: this.configuration.maxDelay,\n        jitter: this.configuration.jitter,\n        timeout: this.configuration.timeout,\n        beforeAttempt: context => {\n          if (!this.shouldConnect || cancelAttempt) {\n            context.abort()\n          }\n        },\n      }).catch((error: any) => {\n        // If we aborted the connection attempt then don’t throw an error\n        // ref: https://github.com/lifeomic/attempt/blob/master/src/index.ts#L136\n        if (error && error.code !== 'ATTEMPT_ABORTED') {\n          throw error\n        }\n      })\n\n      return {\n        retryPromise,\n        cancelFunc: () => {\n          cancelAttempt = true\n        },\n      }\n    }\n\n    const { retryPromise, cancelFunc } = abortableRetry()\n    this.cancelWebsocketRetry = cancelFunc\n\n    return retryPromise\n  }\n\n  attachWebSocketListeners(ws: HocusPocusWebSocket, reject: Function) {\n    const { identifier } = ws\n    const onMessageHandler = (payload: any) => this.emit('message', payload)\n    const onCloseHandler = (payload: any) => this.emit('close', { event: payload })\n    const onOpenHandler = (payload: any) => this.emit('open', payload)\n    const onErrorHandler = (err: any) => {\n      reject(err)\n    }\n\n    this.webSocketHandlers[identifier] = {\n      message: onMessageHandler,\n      close: onCloseHandler,\n      open: onOpenHandler,\n      error: onErrorHandler,\n    }\n\n    const handlers = this.webSocketHandlers[ws.identifier]\n\n    Object.keys(handlers).forEach(name => {\n      ws.addEventListener(name, handlers[name])\n    })\n  }\n\n  cleanupWebSocket() {\n    if (!this.webSocket) {\n      return\n    }\n    const { identifier } = this.webSocket\n    const handlers = this.webSocketHandlers[identifier]\n\n    Object.keys(handlers).forEach(name => {\n      this.webSocket?.removeEventListener(name, handlers[name])\n      delete this.webSocketHandlers[identifier]\n    })\n    this.webSocket.close()\n    this.webSocket = null\n  }\n\n  createWebSocketConnection() {\n    return new Promise((resolve, reject) => {\n      if (this.webSocket) {\n        this.messageQueue = []\n        this.cleanupWebSocket()\n      }\n      this.lastMessageReceived = 0\n      this.identifier += 1\n\n      // Init the WebSocket connection\n      const ws = new this.configuration.WebSocketPolyfill(this.url)\n      ws.binaryType = 'arraybuffer'\n      ws.identifier = this.identifier\n\n      this.attachWebSocketListeners(ws, reject)\n\n      this.webSocket = ws\n\n      // Reset the status\n      this.status = WebSocketStatus.Connecting\n      this.emit('status', { status: WebSocketStatus.Connecting })\n\n      // Store resolve/reject for later use\n      this.connectionAttempt = {\n        resolve,\n        reject,\n      }\n    })\n  }\n\n  onMessage(event: MessageEvent) {\n    this.resolveConnectionAttempt()\n\n    this.lastMessageReceived = time.getUnixTime()\n\n    const message = new IncomingMessage(event.data)\n    const documentName = message.peekVarString()\n\n    this.configuration.providerMap.get(documentName)?.onMessage(event)\n  }\n\n  resolveConnectionAttempt() {\n    if (this.connectionAttempt) {\n      this.connectionAttempt.resolve()\n      this.connectionAttempt = null\n\n      this.status = WebSocketStatus.Connected\n      this.emit('status', { status: WebSocketStatus.Connected })\n      this.emit('connect')\n      this.messageQueue.forEach(message => this.send(message))\n      this.messageQueue = []\n    }\n  }\n\n  stopConnectionAttempt() {\n    this.connectionAttempt = null\n  }\n\n  rejectConnectionAttempt() {\n    this.connectionAttempt?.reject()\n    this.connectionAttempt = null\n  }\n\n  closeTries = 0\n\n  checkConnection() {\n    // Don’t check the connection when it’s not even established\n    if (this.status !== WebSocketStatus.Connected) {\n      return\n    }\n\n    // Don’t close the connection while waiting for the first message\n    if (!this.lastMessageReceived) {\n      return\n    }\n\n    // Don’t close the connection when a message was received recently\n    if (\n      this.configuration.messageReconnectTimeout\n      >= time.getUnixTime() - this.lastMessageReceived\n    ) {\n      return\n    }\n\n    // No message received in a long time, not even your own\n    // Awareness updates, which are updated every 15 seconds\n    // if awareness is enabled.\n    this.closeTries += 1\n    // https://bugs.webkit.org/show_bug.cgi?id=247943\n    if (this.closeTries > 2) {\n      this.onClose({\n        event: {\n          code: 4408,\n          reason: 'forced',\n        },\n      })\n      this.closeTries = 0\n    } else {\n      this.webSocket?.close()\n      this.messageQueue = []\n    }\n  }\n\n  // Ensure that the URL always ends with /\n  get serverUrl() {\n    while (this.configuration.url[this.configuration.url.length - 1] === '/') {\n      return this.configuration.url.slice(0, this.configuration.url.length - 1)\n    }\n\n    return this.configuration.url\n  }\n\n  get url() {\n    const encodedParams = url.encodeQueryParams(this.configuration.parameters)\n\n    return `${this.serverUrl}${encodedParams.length === 0 ? '' : `?${encodedParams}`}`\n  }\n\n  disconnect() {\n    this.shouldConnect = false\n\n    if (this.webSocket === null) {\n      return\n    }\n\n    try {\n      this.webSocket.close()\n      this.messageQueue = []\n    } catch {\n      //\n    }\n  }\n\n  send(message: any) {\n    if (this.webSocket?.readyState === WsReadyStates.Open) {\n      this.webSocket.send(message)\n    } else {\n      this.messageQueue.push(message)\n    }\n  }\n\n  onClose({ event }: onCloseParameters) {\n    this.closeTries = 0\n    this.cleanupWebSocket()\n\n    if (this.status === WebSocketStatus.Connected) {\n      this.status = WebSocketStatus.Disconnected\n      this.emit('status', { status: WebSocketStatus.Disconnected })\n      this.emit('disconnect', { event })\n    }\n\n    if (event.code === Unauthorized.code) {\n      if (event.reason === Unauthorized.reason) {\n        console.warn(\n          '[HocuspocusProvider] An authentication token is required, but you didn’t send one. Try adding a `token` to your HocuspocusProvider configuration. Won’t try again.',\n        )\n      } else {\n        console.warn(\n          `[HocuspocusProvider] Connection closed with status Unauthorized: ${event.reason}`,\n        )\n      }\n\n      this.shouldConnect = false\n    }\n\n    if (event.code === Forbidden.code) {\n      if (!this.configuration.quiet) {\n        console.warn(\n          '[HocuspocusProvider] The provided authentication token isn’t allowed to connect to this server. Will try again.',\n        )\n        return // TODO REMOVE ME\n      }\n    }\n\n    if (event.code === MessageTooBig.code) {\n      console.warn(\n        `[HocuspocusProvider] Connection closed with status MessageTooBig: ${event.reason}`,\n      )\n      this.shouldConnect = false\n    }\n\n    if (this.connectionAttempt) {\n      // That connection attempt failed.\n      this.rejectConnectionAttempt()\n    } else if (this.shouldConnect) {\n      // The connection was closed by the server. Let’s just try again.\n      this.connect()\n    }\n\n    // If we’ll reconnect, we’re done for now.\n    if (this.shouldConnect) {\n      return\n    }\n\n    // The status is set correctly already.\n    if (this.status === WebSocketStatus.Disconnected) {\n      return\n    }\n\n    // Let’s update the connection status.\n    this.status = WebSocketStatus.Disconnected\n    this.emit('status', { status: WebSocketStatus.Disconnected })\n    this.emit('disconnect', { event })\n  }\n\n  destroy() {\n    this.emit('destroy')\n\n    if (this.intervals.forceSync) {\n      clearInterval(this.intervals.forceSync)\n    }\n\n    clearInterval(this.intervals.connectionChecker)\n\n    // If there is still a connection attempt outstanding then we should stop\n    // it before calling disconnect, otherwise it will be rejected in the onClose\n    // handler and trigger a retry\n    this.stopConnectionAttempt()\n\n    this.disconnect()\n\n    this.removeAllListeners()\n\n    this.cleanupWebSocket()\n  }\n}\n", "/**\n * @module sync-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as Y from 'yjs'\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server should only reply to requests, and not initiate them.\n * Therefore it is necessary that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0\nexport const messageYjsSyncStep2 = 1\nexport const messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = Y.encodeStateVector(doc)\n  encoding.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2)\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nexport const readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin)\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error)\n  }\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate)\n  encoding.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Does not need to be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n}\n", "import { Encoder, createEncoder, toUint8Array } from 'lib0/encoding'\nimport { MessageType, OutgoingMessageArguments, OutgoingMessageInterface } from './types.js'\n\nexport class OutgoingMessage implements OutgoingMessageInterface {\n  encoder: Encoder\n\n  type?: MessageType\n\n  constructor() {\n    this.encoder = createEncoder()\n  }\n\n  get(args: Partial<OutgoingMessageArguments>) {\n    return args.encoder\n  }\n\n  toUint8Array() {\n    return toUint8Array(this.encoder)\n  }\n}\n", "import { readAuthMessage } from '@hocuspocus/common'\nimport { readVarInt, readVarString } from 'lib0/decoding'\nimport * as awarenessProtocol from 'y-protocols/awareness'\nimport { messageYjsSyncStep2, readSyncMessage } from 'y-protocols/sync'\nimport { HocuspocusProvider } from './HocuspocusProvider.js'\nimport { IncomingMessage } from './IncomingMessage.js'\nimport { OutgoingMessage } from './OutgoingMessage.js'\nimport { MessageType } from './types.js'\n\nexport class MessageReceiver {\n\n  message: IncomingMessage\n\n  broadcasted = false\n\n  constructor(message: IncomingMessage) {\n    this.message = message\n  }\n\n  public setBroadcasted(value: boolean) {\n    this.broadcasted = value\n\n    return this\n  }\n\n  public apply(provider: HocuspocusProvider, emitSynced: boolean) {\n    const { message } = this\n    const type = message.readVarUint()\n\n    const emptyMessageLength = message.length()\n\n    switch (type) {\n      case MessageType.Sync:\n        this.applySyncMessage(provider, emitSynced)\n        break\n\n      case MessageType.Awareness:\n        this.applyAwarenessMessage(provider)\n        break\n\n      case MessageType.Auth:\n        this.applyAuthMessage(provider)\n        break\n\n      case MessageType.QueryAwareness:\n        this.applyQueryAwarenessMessage(provider)\n        break\n\n      case MessageType.Stateless:\n        provider.receiveStateless(readVarString(message.decoder))\n        break\n\n      case MessageType.SyncStatus:\n        this.applySyncStatusMessage(provider, readVarInt(message.decoder) === 1)\n        break\n      default:\n        throw new Error(`Can’t apply message of unknown type: ${type}`)\n    }\n\n    // Reply\n    if (message.length() > emptyMessageLength + 1) { // length of documentName (considered in emptyMessageLength plus length of yjs sync type, set in applySyncMessage)\n      if (this.broadcasted) {\n        // TODO: Some weird TypeScript error\n        // @ts-ignore\n        provider.broadcast(OutgoingMessage, { encoder: message.encoder })\n      } else {\n        // TODO: Some weird TypeScript error\n        // @ts-ignore\n        provider.send(OutgoingMessage, { encoder: message.encoder })\n      }\n    }\n  }\n\n  private applySyncMessage(provider: HocuspocusProvider, emitSynced: boolean) {\n    const { message } = this\n\n    message.writeVarUint(MessageType.Sync)\n\n    // Apply update\n    const syncMessageType = readSyncMessage(\n      message.decoder,\n      message.encoder,\n      provider.document,\n      provider,\n    )\n\n    // Synced once we receive Step2\n    if (emitSynced && syncMessageType === messageYjsSyncStep2) {\n      provider.synced = true\n    }\n  }\n\n  applySyncStatusMessage(provider: HocuspocusProvider, applied: boolean) {\n    if (applied) {\n      provider.decrementUnsyncedChanges()\n    }\n  }\n\n  private applyAwarenessMessage(provider: HocuspocusProvider) {\n    if (!provider.awareness) return\n\n    const { message } = this\n\n    awarenessProtocol.applyAwarenessUpdate(\n      provider.awareness,\n      message.readVarUint8Array(),\n      provider,\n    )\n  }\n\n  private applyAuthMessage(provider: HocuspocusProvider) {\n    const { message } = this\n\n    readAuthMessage(\n      message.decoder,\n      provider.permissionDeniedHandler.bind(provider),\n      provider.authenticatedHandler.bind(provider),\n    )\n  }\n\n  private applyQueryAwarenessMessage(provider: HocuspocusProvider) {\n    if (!provider.awareness) return\n\n    const { message } = this\n\n    message.writeVarUint(MessageType.Awareness)\n    message.writeVarUint8Array(\n      awarenessProtocol.encodeAwarenessUpdate(\n        provider.awareness,\n        Array.from(provider.awareness.getStates().keys()),\n      ),\n    )\n  }\n}\n", "import { Encoder, toUint8Array } from 'lib0/encoding'\nimport * as bc from 'lib0/broadcastchannel'\nimport { ConstructableOutgoingMessage } from './types.js'\n\nexport class MessageSender {\n\n  encoder: Encoder\n\n  message: any\n\n  constructor(Message: ConstructableOutgoingMessage, args: any = {}) {\n    this.message = new Message()\n    this.encoder = this.message.get(args)\n  }\n\n  create() {\n    return toUint8Array(this.encoder)\n  }\n\n  send(webSocket: any) {\n    webSocket?.send(this.create())\n  }\n\n  broadcast(channel: string) {\n    bc.publish(channel, this.create())\n  }\n}\n", "import { writeVarString, writeVarUint } from 'lib0/encoding'\nimport { writeAuthentication } from '@hocuspocus/common'\nimport { MessageType, OutgoingMessageArguments } from '../types.js'\nimport { OutgoingMessage } from '../OutgoingMessage.js'\n\nexport class AuthenticationMessage extends OutgoingMessage {\n  type = MessageType.Auth\n\n  description = 'Authentication'\n\n  get(args: Partial<OutgoingMessageArguments>) {\n    if (typeof args.token === 'undefined') {\n      throw new Error('The authentication message requires `token` as an argument.')\n    }\n\n    writeVarString(this.encoder, args.documentName!)\n    writeVarUint(this.encoder, this.type)\n    writeAuthentication(this.encoder, args.token)\n\n    return this.encoder\n  }\n}\n", "import * as encoding from 'lib0/encoding'\nimport { encodeAwarenessUpdate } from 'y-protocols/awareness'\nimport { MessageType, OutgoingMessageArguments } from '../types.js'\nimport { OutgoingMessage } from '../OutgoingMessage.js'\n\nexport class AwarenessMessage extends OutgoingMessage {\n  type = MessageType.Awareness\n\n  description = 'Awareness states update'\n\n  get(args: Partial<OutgoingMessageArguments>) {\n    if (typeof args.awareness === 'undefined') {\n      throw new Error('The awareness message requires awareness as an argument')\n    }\n\n    if (typeof args.clients === 'undefined') {\n      throw new Error('The awareness message requires clients as an argument')\n    }\n\n    encoding.writeVarString(this.encoder, args.documentName!)\n    encoding.writeVarUint(this.encoder, this.type)\n\n    let awarenessUpdate\n    if (args.states === undefined) {\n      awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients)\n    } else {\n      awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients, args.states)\n    }\n\n    encoding.writeVarUint8Array(this.encoder, awarenessUpdate)\n\n    return this.encoder\n  }\n}\n", "import * as encoding from 'lib0/encoding'\nimport { MessageType, OutgoingMessageArguments } from '../types.js'\nimport { OutgoingMessage } from '../OutgoingMessage.js'\n\nexport class CloseMessage extends OutgoingMessage {\n  type = MessageType.CLOSE\n\n  description = 'Ask the server to close the connection'\n\n  get(args: Partial<OutgoingMessageArguments>) {\n    encoding.writeVarString(this.encoder, args.documentName!)\n    encoding.writeVarUint(this.encoder, this.type)\n\n    return this.encoder\n  }\n}\n", "import * as encoding from 'lib0/encoding'\nimport { MessageType, OutgoingMessageArguments } from '../types.js'\nimport { OutgoingMessage } from '../OutgoingMessage.js'\n\nexport class QueryAwarenessMessage extends OutgoingMessage {\n  type = MessageType.QueryAwareness\n\n  description = 'Queries awareness states'\n\n  get(args: Partial<OutgoingMessageArguments>) {\n\n    encoding.writeVarString(this.encoder, args.documentName!)\n    encoding.writeVarUint(this.encoder, this.type)\n\n    return this.encoder\n  }\n}\n", "import { writeVarString, writeVarUint } from 'lib0/encoding'\nimport { MessageType, OutgoingMessageArguments } from '../types.js'\nimport { OutgoingMessage } from '../OutgoingMessage.js'\n\nexport class StatelessMessage extends OutgoingMessage {\n  type = MessageType.Stateless\n\n  description = 'A stateless message'\n\n  get(args: Partial<OutgoingMessageArguments>) {\n    writeVarString(this.encoder, args.documentName!)\n    writeVarUint(this.encoder, this.type)\n    writeVarString(this.encoder, args.payload ?? '')\n\n    return this.encoder\n  }\n}\n", "import * as encoding from 'lib0/encoding'\nimport * as syncProtocol from 'y-protocols/sync'\nimport { MessageType, OutgoingMessageArguments } from '../types.js'\nimport { OutgoingMessage } from '../OutgoingMessage.js'\n\nexport class SyncStepOneMessage extends OutgoingMessage {\n  type = MessageType.Sync\n\n  description = 'First sync step'\n\n  get(args: Partial<OutgoingMessageArguments>) {\n    if (typeof args.document === 'undefined') {\n      throw new Error('The sync step one message requires document as an argument')\n    }\n\n    encoding.writeVarString(this.encoder, args.documentName!)\n    encoding.writeVarUint(this.encoder, this.type)\n    syncProtocol.writeSyncStep1(this.encoder, args.document)\n\n    return this.encoder\n  }\n}\n", "import * as encoding from 'lib0/encoding'\nimport * as syncProtocol from 'y-protocols/sync'\nimport { MessageType, OutgoingMessageArguments } from '../types.js'\nimport { OutgoingMessage } from '../OutgoingMessage.js'\n\nexport class SyncStepTwoMessage extends OutgoingMessage {\n  type = MessageType.Sync\n\n  description = 'Second sync step'\n\n  get(args: Partial<OutgoingMessageArguments>) {\n    if (typeof args.document === 'undefined') {\n      throw new Error('The sync step two message requires document as an argument')\n    }\n\n    encoding.writeVarString(this.encoder, args.documentName!)\n    encoding.writeVarUint(this.encoder, this.type)\n    syncProtocol.writeSyncStep2(this.encoder, args.document)\n\n    return this.encoder\n  }\n}\n", "import { writeVarString, writeVarUint } from 'lib0/encoding'\nimport { writeUpdate } from 'y-protocols/sync'\nimport { MessageType, OutgoingMessageArguments } from '../types.js'\nimport { OutgoingMessage } from '../OutgoingMessage.js'\n\nexport class UpdateMessage extends OutgoingMessage {\n  type = MessageType.Sync\n\n  description = 'A document update'\n\n  get(args: Partial<OutgoingMessageArguments>) {\n    writeVarString(this.encoder, args.documentName!)\n    writeVarUint(this.encoder, this.type)\n\n    writeUpdate(this.encoder, args.update)\n\n    return this.encoder\n  }\n}\n", "import { awarenessStatesToArray } from '@hocuspocus/common'\nimport * as bc from 'lib0/broadcastchannel'\nimport * as mutex from 'lib0/mutex'\nimport type { CloseEvent, Event, MessageEvent } from 'ws'\nimport { Awareness, removeAwarenessStates } from 'y-protocols/awareness'\nimport * as Y from 'yjs'\nimport EventEmitter from './EventEmitter.js'\nimport {\n  CompleteHocuspocusProviderWebsocketConfiguration,\n  HocuspocusProviderWebsocket,\n} from './HocuspocusProviderWebsocket.js'\nimport { IncomingMessage } from './IncomingMessage.js'\nimport { MessageReceiver } from './MessageReceiver.js'\nimport { MessageSender } from './MessageSender.js'\nimport { AuthenticationMessage } from './OutgoingMessages/AuthenticationMessage.js'\nimport { AwarenessMessage } from './OutgoingMessages/AwarenessMessage.js'\nimport { CloseMessage } from './OutgoingMessages/CloseMessage.js'\nimport { QueryAwarenessMessage } from './OutgoingMessages/QueryAwarenessMessage.js'\nimport { StatelessMessage } from './OutgoingMessages/StatelessMessage.js'\nimport { SyncStepOneMessage } from './OutgoingMessages/SyncStepOneMessage.js'\nimport { SyncStepTwoMessage } from './OutgoingMessages/SyncStepTwoMessage.js'\nimport { UpdateMessage } from './OutgoingMessages/UpdateMessage.js'\nimport {\n  ConstructableOutgoingMessage,\n  WebSocketStatus,\n  onAuthenticationFailedParameters,\n  onAwarenessChangeParameters,\n  onAwarenessUpdateParameters,\n  onCloseParameters,\n  onDisconnectParameters,\n  onMessageParameters,\n  onOpenParameters,\n  onOutgoingMessageParameters, onStatelessParameters,\n  onStatusParameters,\n  onSyncedParameters,\n} from './types.js'\n\nexport type HocuspocusProviderConfiguration =\n  Required<Pick<CompleteHocuspocusProviderConfiguration, 'name'>>\n    & Partial<CompleteHocuspocusProviderConfiguration> & (\n  Required<Pick<CompleteHocuspocusProviderWebsocketConfiguration, 'url'>> |\n  Required<Pick<CompleteHocuspocusProviderConfiguration, 'websocketProvider'>>\n  )\n\nexport interface CompleteHocuspocusProviderConfiguration {\n  /**\n  * The identifier/name of your document\n  */\n   name: string,\n  /**\n   * The actual Y.js document\n   */\n  document: Y.Doc,\n\n  /**\n   * Pass false to disable broadcasting between browser tabs.\n   */\n  broadcast: boolean,\n  /**\n   * An Awareness instance to keep the presence state of all clients.\n   *\n   * You can disable sharing awareness information by passing `null`.\n   * Note that having no awareness information shared across all connections will break our ping checks\n   * and thus trigger reconnects. You should always have at least one Provider with enabled awareness per\n   * socket connection, or ensure that the Provider receives messages before running into `HocuspocusProviderWebsocket.messageReconnectTimeout`.\n   */\n  awareness: Awareness | null,\n  /**\n   * A token that’s sent to the backend for authentication purposes.\n   */\n  token: string | (() => string) | (() => Promise<string>) | null,\n  /**\n   * URL parameters that should be added.\n   */\n  parameters: { [key: string]: any },\n  /**\n   * Hocuspocus websocket provider\n   */\n  websocketProvider: HocuspocusProviderWebsocket,\n  /**\n   * Force syncing the document in the defined interval.\n   */\n  forceSyncInterval: false | number,\n\n  onAuthenticated: () => void,\n  onAuthenticationFailed: (data: onAuthenticationFailedParameters) => void,\n  onOpen: (data: onOpenParameters) => void,\n  onConnect: () => void,\n  onMessage: (data: onMessageParameters) => void,\n  onOutgoingMessage: (data: onOutgoingMessageParameters) => void,\n  onStatus: (data: onStatusParameters) => void,\n  onSynced: (data: onSyncedParameters) => void,\n  onDisconnect: (data: onDisconnectParameters) => void,\n  onClose: (data: onCloseParameters) => void,\n  onDestroy: () => void,\n  onAwarenessUpdate: (data: onAwarenessUpdateParameters) => void,\n  onAwarenessChange: (data: onAwarenessChangeParameters) => void,\n  onStateless: (data: onStatelessParameters) => void\n\n  /**\n   * Don’t output any warnings.\n   */\n  quiet: boolean,\n\n  /**\n   * Pass `false` to start the connection manually.\n   */\n  connect: boolean,\n\n  /**\n   * Pass `false` to close the connection manually.\n   */\n  preserveConnection: boolean,\n}\n\nexport class AwarenessError extends Error {\n  code = 1001\n}\n\nexport class HocuspocusProvider extends EventEmitter {\n  public configuration: CompleteHocuspocusProviderConfiguration = {\n    name: '',\n    // @ts-ignore\n    document: undefined,\n    // @ts-ignore\n    awareness: undefined,\n    token: null,\n    parameters: {},\n    broadcast: true,\n    forceSyncInterval: false,\n    onAuthenticated: () => null,\n    onAuthenticationFailed: () => null,\n    onOpen: () => null,\n    onConnect: () => null,\n    onMessage: () => null,\n    onOutgoingMessage: () => null,\n    onStatus: () => null,\n    onSynced: () => null,\n    onDisconnect: () => null,\n    onClose: () => null,\n    onDestroy: () => null,\n    onAwarenessUpdate: () => null,\n    onAwarenessChange: () => null,\n    onStateless: () => null,\n    quiet: false,\n    connect: true,\n    preserveConnection: true,\n  }\n\n  subscribedToBroadcastChannel = false\n\n  isSynced = false\n\n  unsyncedChanges = 0\n\n  status = WebSocketStatus.Disconnected\n\n  isAuthenticated = false\n\n  authorizedScope: string | undefined = undefined\n\n  mux = mutex.createMutex()\n\n  intervals: any = {\n    forceSync: null,\n  }\n\n  isConnected = true\n\n  constructor(configuration: HocuspocusProviderConfiguration) {\n    super()\n    this.setConfiguration(configuration)\n\n    this.configuration.document = configuration.document ? configuration.document : new Y.Doc()\n    this.configuration.awareness = configuration.awareness !== undefined ? configuration.awareness : new Awareness(this.document)\n\n    this.on('open', this.configuration.onOpen)\n    this.on('message', this.configuration.onMessage)\n    this.on('outgoingMessage', this.configuration.onOutgoingMessage)\n    this.on('synced', this.configuration.onSynced)\n    this.on('destroy', this.configuration.onDestroy)\n    this.on('awarenessUpdate', this.configuration.onAwarenessUpdate)\n    this.on('awarenessChange', this.configuration.onAwarenessChange)\n    this.on('stateless', this.configuration.onStateless)\n\n    this.on('authenticated', this.configuration.onAuthenticated)\n    this.on('authenticationFailed', this.configuration.onAuthenticationFailed)\n\n    this.configuration.websocketProvider.on('connect', this.configuration.onConnect)\n    this.configuration.websocketProvider.on('connect', this.forwardConnect)\n\n    this.configuration.websocketProvider.on('open', this.boundOnOpen)\n    this.configuration.websocketProvider.on('open', this.forwardOpen)\n\n    this.configuration.websocketProvider.on('close', this.boundOnClose)\n    this.configuration.websocketProvider.on('close', this.configuration.onClose)\n    this.configuration.websocketProvider.on('close', this.forwardClose)\n\n    this.configuration.websocketProvider.on('status', this.boundOnStatus)\n\n    this.configuration.websocketProvider.on('disconnect', this.configuration.onDisconnect)\n    this.configuration.websocketProvider.on('disconnect', this.forwardDisconnect)\n\n    this.configuration.websocketProvider.on('destroy', this.configuration.onDestroy)\n    this.configuration.websocketProvider.on('destroy', this.forwardDestroy)\n\n    this.awareness?.on('update', () => {\n      this.emit('awarenessUpdate', { states: awarenessStatesToArray(this.awareness!.getStates()) })\n    })\n\n    this.awareness?.on('change', () => {\n      this.emit('awarenessChange', { states: awarenessStatesToArray(this.awareness!.getStates()) })\n    })\n\n    this.document.on('update', this.boundDocumentUpdateHandler)\n    this.awareness?.on('update', this.boundAwarenessUpdateHandler)\n    this.registerEventListeners()\n\n    if (\n      this.configuration.forceSyncInterval\n      && typeof this.configuration.forceSyncInterval === 'number'\n    ) {\n      this.intervals.forceSync = setInterval(\n        this.forceSync.bind(this),\n        this.configuration.forceSyncInterval,\n      )\n    }\n\n    this.configuration.websocketProvider.attach(this)\n  }\n\n  boundDocumentUpdateHandler = this.documentUpdateHandler.bind(this)\n\n  boundAwarenessUpdateHandler = this.awarenessUpdateHandler.bind(this)\n\n  boundBroadcastChannelSubscriber = this.broadcastChannelSubscriber.bind(this)\n\n  boundPageHide = this.pageHide.bind(this)\n\n  boundOnOpen = this.onOpen.bind(this)\n\n  boundOnClose = this.onClose.bind(this)\n\n  boundOnStatus = this.onStatus.bind(this)\n\n  forwardConnect = (e: any) => this.emit('connect', e)\n\n  forwardOpen = (e: any) => this.emit('open', e)\n\n  forwardClose = (e: any) => this.emit('close', e)\n\n  forwardDisconnect = (e: any) => this.emit('disconnect', e)\n\n  forwardDestroy = (e: any) => this.emit('destroy', e)\n\n  public onStatus({ status } : onStatusParameters) {\n    this.status = status\n\n    this.configuration.onStatus({ status })\n    this.emit('status', { status })\n  }\n\n  public setConfiguration(configuration: Partial<HocuspocusProviderConfiguration> = {}): void {\n    if (!configuration.websocketProvider && (configuration as CompleteHocuspocusProviderWebsocketConfiguration).url) {\n      const websocketProviderConfig = configuration as CompleteHocuspocusProviderWebsocketConfiguration\n\n      this.configuration.websocketProvider = new HocuspocusProviderWebsocket({\n        url: websocketProviderConfig.url,\n        connect: websocketProviderConfig.connect,\n        parameters: websocketProviderConfig.parameters,\n      })\n    }\n\n    this.configuration = { ...this.configuration, ...configuration }\n  }\n\n  get document() {\n    return this.configuration.document\n  }\n\n  get awareness() {\n    return this.configuration.awareness\n  }\n\n  get hasUnsyncedChanges(): boolean {\n    return this.unsyncedChanges > 0\n  }\n\n  private resetUnsyncedChanges() {\n    this.unsyncedChanges = 1\n    this.emit('unsyncedChanges', this.unsyncedChanges)\n  }\n\n  incrementUnsyncedChanges() {\n    this.unsyncedChanges += 1\n    this.emit('unsyncedChanges', this.unsyncedChanges)\n  }\n\n  decrementUnsyncedChanges() {\n    this.unsyncedChanges -= 1\n    if (this.unsyncedChanges === 0) {\n      this.synced = true\n    }\n    this.emit('unsyncedChanges', this.unsyncedChanges)\n  }\n\n  forceSync() {\n    this.resetUnsyncedChanges()\n\n    this.send(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name })\n  }\n\n  pageHide() {\n    if (this.awareness) {\n      removeAwarenessStates(this.awareness, [this.document.clientID], 'page hide')\n    }\n  }\n\n  registerEventListeners() {\n    if (typeof window === 'undefined' || !('addEventListener' in window)) {\n      return\n    }\n\n    window.addEventListener('pagehide', this.boundPageHide)\n  }\n\n  sendStateless(payload: string) {\n    this.send(StatelessMessage, { documentName: this.configuration.name, payload })\n  }\n\n  documentUpdateHandler(update: Uint8Array, origin: any) {\n    if (origin === this) {\n      return\n    }\n\n    this.incrementUnsyncedChanges()\n    this.send(UpdateMessage, { update, documentName: this.configuration.name }, true)\n  }\n\n  awarenessUpdateHandler({ added, updated, removed }: any, origin: any) {\n    const changedClients = added.concat(updated).concat(removed)\n\n    this.send(AwarenessMessage, {\n      awareness: this.awareness,\n      clients: changedClients,\n      documentName: this.configuration.name,\n    }, true)\n  }\n\n  /**\n   * Indicates whether a first handshake with the server has been established\n   *\n   * Note: this does not mean all updates from the client have been persisted to the backend. For this,\n   * use `hasUnsyncedChanges`.\n   */\n  get synced(): boolean {\n    return this.isSynced\n  }\n\n  set synced(state) {\n    if (this.isSynced === state) {\n      return\n    }\n\n    this.isSynced = state\n    this.emit('synced', { state })\n    this.emit('sync', { state })\n  }\n\n  receiveStateless(payload: string) {\n    this.emit('stateless', { payload })\n  }\n\n  get isAuthenticationRequired(): boolean {\n    return !!this.configuration.token && !this.isAuthenticated\n  }\n\n  // not needed, but provides backward compatibility with e.g. lexical/yjs\n  async connect() {\n    if (this.configuration.broadcast) {\n      this.subscribeToBroadcastChannel()\n    }\n\n    this.configuration.websocketProvider.shouldConnect = true\n\n    return this.configuration.websocketProvider.attach(this)\n  }\n\n  disconnect() {\n    this.disconnectBroadcastChannel()\n    this.configuration.websocketProvider.detach(this)\n    this.isConnected = false\n\n    if (!this.configuration.preserveConnection) {\n      this.configuration.websocketProvider.disconnect()\n    }\n\n  }\n\n  async onOpen(event: Event) {\n    this.isAuthenticated = false\n    this.isConnected = true\n\n    this.emit('open', { event })\n\n    let token: string | null\n    try {\n      token = await this.getToken()\n    } catch (error) {\n      this.permissionDeniedHandler(`Failed to get token: ${error}`)\n      return\n    }\n\n    if (this.isAuthenticationRequired) {\n      this.send(AuthenticationMessage, {\n        token,\n        documentName: this.configuration.name,\n      })\n    }\n\n    this.startSync()\n  }\n\n  async getToken() {\n    if (typeof this.configuration.token === 'function') {\n      const token = await this.configuration.token()\n      return token\n    }\n\n    return this.configuration.token\n  }\n\n  startSync() {\n    this.resetUnsyncedChanges()\n\n    this.send(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name })\n\n    if (this.awareness && this.awareness.getLocalState() !== null) {\n      this.send(AwarenessMessage, {\n        awareness: this.awareness,\n        clients: [this.document.clientID],\n        documentName: this.configuration.name,\n      })\n    }\n  }\n\n  send(message: ConstructableOutgoingMessage, args: any, broadcast = false) {\n    if (!this.isConnected) {\n      return\n    }\n\n    if (broadcast) {\n      this.mux(() => { this.broadcast(message, args) })\n    }\n\n    const messageSender = new MessageSender(message, args)\n\n    this.emit('outgoingMessage', { message: messageSender.message })\n    messageSender.send(this.configuration.websocketProvider)\n  }\n\n  onMessage(event: MessageEvent) {\n    const message = new IncomingMessage(event.data)\n\n    const documentName = message.readVarString()\n\n    message.writeVarString(documentName)\n\n    this.emit('message', { event, message: new IncomingMessage(event.data) })\n\n    new MessageReceiver(message).apply(this, true)\n  }\n\n  onClose(event: CloseEvent) {\n    this.isAuthenticated = false\n    this.synced = false\n\n    // update awareness (all users except local left)\n    if (this.awareness) {\n      removeAwarenessStates(\n        this.awareness,\n        Array.from(this.awareness.getStates().keys()).filter(client => client !== this.document.clientID),\n        this,\n      )\n    }\n  }\n\n  destroy() {\n    this.emit('destroy')\n\n    if (this.intervals.forceSync) {\n      clearInterval(this.intervals.forceSync)\n    }\n\n    if (this.awareness) {\n      removeAwarenessStates(this.awareness, [this.document.clientID], 'provider destroy')\n      this.awareness.off('update', this.boundAwarenessUpdateHandler)\n      this.awareness.destroy()\n    }\n\n    this.document.off('update', this.boundDocumentUpdateHandler)\n\n    this.removeAllListeners()\n\n    this.configuration.websocketProvider.off('connect', this.configuration.onConnect)\n    this.configuration.websocketProvider.off('connect', this.forwardConnect)\n    this.configuration.websocketProvider.off('open', this.boundOnOpen)\n    this.configuration.websocketProvider.off('open', this.forwardOpen)\n    this.configuration.websocketProvider.off('close', this.boundOnClose)\n    this.configuration.websocketProvider.off('close', this.configuration.onClose)\n    this.configuration.websocketProvider.off('close', this.forwardClose)\n    this.configuration.websocketProvider.off('status', this.boundOnStatus)\n    this.configuration.websocketProvider.off('disconnect', this.configuration.onDisconnect)\n    this.configuration.websocketProvider.off('disconnect', this.forwardDisconnect)\n    this.configuration.websocketProvider.off('destroy', this.configuration.onDestroy)\n    this.configuration.websocketProvider.off('destroy', this.forwardDestroy)\n\n    this.send(CloseMessage, { documentName: this.configuration.name })\n    this.disconnect()\n\n    if (typeof window === 'undefined' || !('removeEventListener' in window)) {\n      return\n    }\n\n    window.removeEventListener('pagehide', this.boundPageHide)\n  }\n\n  permissionDeniedHandler(reason: string) {\n    this.emit('authenticationFailed', { reason })\n    this.isAuthenticated = false\n    this.disconnect()\n    this.status = WebSocketStatus.Disconnected\n  }\n\n  authenticatedHandler(scope: string) {\n    this.isAuthenticated = true\n    this.authorizedScope = scope\n\n    this.emit('authenticated')\n  }\n\n  get broadcastChannel() {\n    return `${this.configuration.name}`\n  }\n\n  broadcastChannelSubscriber(data: ArrayBuffer) {\n    this.mux(() => {\n      const message = new IncomingMessage(data)\n\n      const documentName = message.readVarString()\n\n      message.writeVarString(documentName)\n\n      new MessageReceiver(message)\n        .setBroadcasted(true)\n        .apply(this, false)\n    })\n  }\n\n  subscribeToBroadcastChannel() {\n    if (!this.subscribedToBroadcastChannel) {\n      bc.subscribe(this.broadcastChannel, this.boundBroadcastChannelSubscriber)\n      this.subscribedToBroadcastChannel = true\n    }\n\n    this.mux(() => {\n      this.broadcast(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name })\n      this.broadcast(SyncStepTwoMessage, { document: this.document, documentName: this.configuration.name })\n      this.broadcast(QueryAwarenessMessage, { document: this.document, documentName: this.configuration.name })\n      if (this.awareness) {\n        this.broadcast(AwarenessMessage, {\n          awareness: this.awareness,\n          clients: [this.document.clientID],\n          document: this.document,\n          documentName: this.configuration.name,\n        })\n      }\n    })\n  }\n\n  disconnectBroadcastChannel() {\n    // broadcast message with local awareness state set to null (indicating disconnect)\n    if (this.awareness) {\n      this.send(AwarenessMessage, {\n        awareness: this.awareness,\n        clients: [this.document.clientID],\n        states: new Map(),\n        documentName: this.configuration.name,\n      }, true)\n    }\n\n    if (this.subscribedToBroadcastChannel) {\n      bc.unsubscribe(this.broadcastChannel, this.boundBroadcastChannelSubscriber)\n      this.subscribedToBroadcastChannel = false\n    }\n  }\n\n  broadcast(Message: ConstructableOutgoingMessage, args?: any) {\n    if (!this.configuration.broadcast) {\n      return\n    }\n\n    if (!this.subscribedToBroadcastChannel) {\n      return\n    }\n\n    new MessageSender(Message, args).broadcast(this.broadcastChannel)\n  }\n\n  setAwarenessField(key: string, value: any) {\n    if (!this.awareness) {\n      throw new AwarenessError(`Cannot set awareness field \"${key}\" to ${JSON.stringify(value)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`)\n    }\n    this.awareness.setLocalStateField(key, value)\n  }\n}\n", "/* eslint-env browser */\n\nexport const subtle = crypto.subtle\nexport const getRandomValues = crypto.getRandomValues.bind(crypto)\n", "/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\nimport { getRandomValues } from 'lib0/webcrypto'\n\nexport const rand = Math.random\n\nexport const uint32 = () => getRandomValues(new Uint32Array(1))[0]\n\nexport const uint53 = () => {\n  const arr = getRandomValues(new Uint32Array(8))\n  return (arr[0] & binary.BITS21) * (binary.BITS32 + 1) + (arr[1] >>> 0)\n}\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nexport const oneOf = arr => arr[math.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\n\n/**\n * @return {string}\n */\nexport const uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n", "import {\n  CompleteHocuspocusProviderWebsocketConfiguration,\n  HocuspocusProviderWebsocket, HocuspocusProviderWebsocketConfiguration,\n} from './HocuspocusProviderWebsocket.js'\n\nexport type TiptapCollabProviderWebsocketConfiguration =\n  Partial<CompleteHocuspocusProviderWebsocketConfiguration> &\n  AdditionalTiptapCollabProviderWebsocketConfiguration\n\nexport interface AdditionalTiptapCollabProviderWebsocketConfiguration {\n  /**\n   * A Hocuspocus Cloud App ID, get one here: https://cloud.tiptap.dev\n   */\n  appId?: string,\n\n  /**\n   * If you are using the on-premise version of TiptapCollab, put your baseUrl here (e.g. https://collab.yourdomain.com)\n   */\n  baseUrl?: string\n\n  /**\n   * Only fill this if you are using Tiptap Collab HA.\n   */\n  shardKey?: string\n}\n\nexport class TiptapCollabProviderWebsocket extends HocuspocusProviderWebsocket {\n  constructor(configuration: TiptapCollabProviderWebsocketConfiguration) {\n    let url = configuration.baseUrl ?? `wss://${configuration.appId}.collab.tiptap.cloud`\n\n    if (configuration.shardKey) {\n      url += url.includes('?') ? '&' : '?'\n      url += `shard=${configuration.shardKey}`\n    }\n\n    super({ ...configuration as HocuspocusProviderWebsocketConfiguration, url })\n  }\n}\n", "import type { AbstractType, YArrayEvent } from 'yjs'\nimport * as Y from 'yjs'\nimport { uuidv4 } from 'lib0/random'\nimport {\n  HocuspocusProvider,\n  HocuspocusProviderConfiguration,\n} from './HocuspocusProvider.js'\n\nimport { TiptapCollabProviderWebsocket } from './TiptapCollabProviderWebsocket.js'\nimport {\n  type DeleteCommentOptions,\n  type DeleteThreadOptions,\n  type GetThreadsOptions,\n  type TCollabComment, type TCollabThread, type THistoryVersion,\n} from './types.js'\n\nconst defaultDeleteCommentOptions: DeleteCommentOptions = {\n  deleteContent: false,\n  deleteThread: false,\n}\n\nconst defaultGetThreadsOptions: GetThreadsOptions = {\n  types: ['unarchived'],\n}\n\nconst defaultDeleteThreadOptions: DeleteThreadOptions = {\n  deleteComments: false,\n  force: false,\n}\n\nexport type TiptapCollabProviderConfiguration =\n  Required<Pick<HocuspocusProviderConfiguration, 'name'>> &\n  Partial<HocuspocusProviderConfiguration> &\n  (Required<Pick<AdditionalTiptapCollabProviderConfiguration, 'websocketProvider'>> |\n  Required<Pick<AdditionalTiptapCollabProviderConfiguration, 'appId'>>|\n  Required<Pick<AdditionalTiptapCollabProviderConfiguration, 'baseUrl'>>) &\n  Pick<AdditionalTiptapCollabProviderConfiguration, 'user'> & {\n    /**\n     * Pass `true` if you want to delete a thread when the first comment is deleted.\n     */\n    deleteThreadOnFirstCommentDelete?: boolean,\n  }\n\nexport interface AdditionalTiptapCollabProviderConfiguration {\n  /**\n   * A Hocuspocus Cloud App ID, get one here: https://cloud.tiptap.dev\n   */\n  appId?: string,\n\n  /**\n   * If you are using the on-premise version of TiptapCollab, put your baseUrl here (e.g. https://collab.yourdomain.com)\n   */\n  baseUrl?: string\n\n  websocketProvider?: TiptapCollabProviderWebsocket\n\n  user?: string\n}\n\nexport class TiptapCollabProvider extends HocuspocusProvider {\n  tiptapCollabConfigurationPrefix = '__tiptapcollab__'\n\n  userData?: Y.PermanentUserData\n\n  constructor(configuration: TiptapCollabProviderConfiguration) {\n    if (!configuration.websocketProvider) {\n      configuration.websocketProvider = new TiptapCollabProviderWebsocket({ appId: (configuration as Required<Pick<AdditionalTiptapCollabProviderConfiguration, 'appId'>>).appId, baseUrl: (configuration as Required<Pick<AdditionalTiptapCollabProviderConfiguration, 'baseUrl'>>).baseUrl })\n    }\n\n    if (!configuration.token) {\n      configuration.token = 'notoken' // need to send a token anyway (which will be ignored)\n    }\n\n    super(configuration as HocuspocusProviderConfiguration)\n\n    if (configuration.user) {\n      this.userData = new Y.PermanentUserData(this.document, this.document.getMap('__tiptapcollab__users'))\n      this.userData.setUserMapping(this.document, this.document.clientID, configuration.user)\n    }\n  }\n\n  /**\n   * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.\n   */\n  createVersion(name?: string) {\n    return this.sendStateless(JSON.stringify({ action: 'version.create', name }))\n  }\n\n  /**\n   * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.\n   */\n  revertToVersion(targetVersion: number) {\n    return this.sendStateless(JSON.stringify({ action: 'document.revert', version: targetVersion }))\n  }\n\n  /**\n   * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.\n   *\n   * The server will reply with a stateless message (THistoryVersionPreviewEvent)\n   */\n  previewVersion(targetVersion: number) {\n    return this.sendStateless(JSON.stringify({ action: 'version.preview', version: targetVersion }))\n  }\n\n  /**\n   * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.\n   */\n  getVersions(): THistoryVersion[] {\n    return this.configuration.document.getArray<THistoryVersion>(`${this.tiptapCollabConfigurationPrefix}versions`).toArray()\n  }\n\n  watchVersions(callback: Parameters<AbstractType<YArrayEvent<THistoryVersion>>['observe']>[0]) {\n    return this.configuration.document.getArray<THistoryVersion>('__tiptapcollab__versions').observe(callback)\n  }\n\n  unwatchVersions(callback: Parameters<AbstractType<YArrayEvent<THistoryVersion>>['unobserve']>[0]) {\n    return this.configuration.document.getArray<THistoryVersion>('__tiptapcollab__versions').unobserve(callback)\n  }\n\n  isAutoVersioning(): boolean {\n    return !!this.configuration.document.getMap<number>(`${this.tiptapCollabConfigurationPrefix}config`).get('autoVersioning')\n  }\n\n  enableAutoVersioning() {\n    return this.configuration.document.getMap<number>(`${this.tiptapCollabConfigurationPrefix}config`).set('autoVersioning', 1)\n  }\n\n  disableAutoVersioning() {\n    return this.configuration.document.getMap<number>(`${this.tiptapCollabConfigurationPrefix}config`).set('autoVersioning', 0)\n  }\n\n  /**\n   * Returns all users in the document as Y.Map objects\n   * @returns An array of Y.Map objects\n   */\n  private getYThreads() {\n    return this.configuration.document.getArray<Y.Map<any>>(`${this.tiptapCollabConfigurationPrefix}threads`)\n  }\n\n  /**\n   * Finds all threads in the document and returns them as JSON objects\n   * @options Options to control the output of the threads (e.g. include deleted threads)\n   * @returns An array of threads as JSON objects\n   */\n  getThreads<Data, CommentData>(options?: GetThreadsOptions): TCollabThread<Data, CommentData>[] {\n    const { types } = { ...defaultGetThreadsOptions, ...options } as GetThreadsOptions\n\n    const threads = this.getYThreads().toJSON() as TCollabThread<Data, CommentData>[]\n\n    if (types?.includes('archived') && types?.includes('unarchived')) {\n      return threads\n    }\n\n    return threads.filter(currentThead => {\n      if (types?.includes('archived') && currentThead.deletedAt) {\n        return true\n      }\n\n      if (types?.includes('unarchived') && !currentThead.deletedAt) {\n        return true\n      }\n\n      return false\n    })\n  }\n\n  /**\n   * Find the index of a thread by its id\n   * @param id The thread id\n   * @returns The index of the thread or null if not found\n   */\n  private getThreadIndex(id: string): number | null {\n    let index = null\n\n    let i = 0\n    // eslint-disable-next-line no-restricted-syntax\n    for (const thread of this.getThreads({ types: ['archived', 'unarchived'] })) {\n      if (thread.id === id) {\n        index = i\n        break\n      }\n      i += 1\n    }\n\n    return index\n  }\n\n  /**\n   * Gets a single thread by its id\n   * @param id The thread id\n   * @returns The thread as a JSON object or null if not found\n   */\n  getThread<Data, CommentData>(id: string): TCollabThread<Data, CommentData> | null {\n    const index = this.getThreadIndex(id)\n\n    if (index === null) {\n      return null\n    }\n\n    return this.getYThreads().get(index).toJSON() as TCollabThread<Data, CommentData>\n  }\n\n  /**\n   * Gets a single thread by its id as a Y.Map object\n   * @param id The thread id\n   * @returns The thread as a Y.Map object or null if not found\n   */\n  private getYThread(id: string) {\n    const index = this.getThreadIndex(id)\n\n    if (index === null) {\n      return null\n    }\n\n    return this.getYThreads().get(index)\n  }\n\n  /**\n   * Create a new thread\n   * @param data The thread data\n   * @returns The created thread\n   */\n  createThread(data: Omit<TCollabThread, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt' | 'comments' | 'deletedComments'>) {\n    let createdThread: TCollabThread = {} as TCollabThread\n\n    this.document.transact(() => {\n      const thread = new Y.Map()\n      thread.set('id', uuidv4())\n      thread.set('createdAt', (new Date()).toISOString())\n      thread.set('comments', new Y.Array())\n      thread.set('deletedComments', new Y.Array())\n      thread.set('deletedAt', null)\n\n      this.getYThreads().push([thread])\n      createdThread = this.updateThread(String(thread.get('id')), data)\n    })\n\n    return createdThread\n  }\n\n  /**\n   * Update a specific thread\n   * @param id The thread id\n   * @param data New data for the thread\n   * @returns The updated thread or null if the thread is not found\n   */\n  updateThread(id: TCollabThread['id'], data: Partial<Pick<TCollabThread, 'data'> & {\n    resolvedAt: TCollabThread['resolvedAt'] | null\n  }>) {\n    let updatedThread: TCollabThread = {} as TCollabThread\n\n    this.document.transact(() => {\n      const thread = this.getYThread(id)\n\n      if (thread === null) {\n        return null\n      }\n\n      thread.set('updatedAt', (new Date()).toISOString())\n\n      if (data.data) {\n        thread.set('data', data.data)\n      }\n\n      if (data.resolvedAt || data.resolvedAt === null) {\n        thread.set('resolvedAt', data.resolvedAt)\n      }\n\n      updatedThread = thread.toJSON() as TCollabThread\n    })\n\n    return updatedThread\n  }\n\n  /**\n   * Handle the deletion of a thread. By default, the thread and it's comments are not deleted, but marked as deleted\n   * via the `deletedAt` property. Forceful deletion can be enabled by setting the `force` option to `true`.\n   *\n   * If you only want to delete the comments of a thread, you can set the `deleteComments` option to `true`.\n   * @param id The thread id\n   * @param options A set of options that control how the thread is deleted\n   * @returns The deleted thread or null if the thread is not found\n   */\n  deleteThread(id: TCollabThread['id'], options?: DeleteThreadOptions) {\n    const { deleteComments, force } = { ...defaultDeleteThreadOptions, ...options }\n\n    const index = this.getThreadIndex(id)\n\n    if (index === null) {\n      return null\n    }\n\n    if (force) {\n      this.getYThreads().delete(index, 1)\n      return\n    }\n\n    const thread = this.getYThreads().get(index)\n\n    thread.set('deletedAt', (new Date()).toISOString())\n\n    if (deleteComments) {\n      thread.set('comments', new Y.Array())\n      thread.set('deletedComments', new Y.Array())\n    }\n\n    return thread.toJSON() as TCollabThread\n  }\n\n  /**\n   * Tries to restore a deleted thread\n   * @param id The thread id\n   * @returns The restored thread or null if the thread is not found\n   */\n  restoreThread(id: TCollabThread['id']) {\n    const index = this.getThreadIndex(id)\n\n    if (index === null) {\n      return null\n    }\n\n    const thread = this.getYThreads().get(index)\n\n    thread.set('deletedAt', null)\n\n    return thread.toJSON() as TCollabThread\n  }\n\n  /**\n   * Returns comments from a thread, either deleted or not\n   * @param threadId The thread id\n   * @param includeDeleted If you want to include deleted comments, defaults to `false`\n   * @returns The comments or null if the thread is not found\n   */\n  getThreadComments(threadId: TCollabThread['id'], includeDeleted?: boolean): TCollabComment[] | null {\n    const index = this.getThreadIndex(threadId)\n\n    if (index === null) {\n      return null\n    }\n\n    const comments = !includeDeleted ? this.getThread(threadId)?.comments : [...(this.getThread(threadId)?.comments || []), ...(this.getThread(threadId)?.deletedComments || [])].sort((a, b) => {\n      return a.createdAt.localeCompare(b.createdAt)\n    })\n\n    return comments ?? []\n  }\n\n  /**\n   * Get a single comment from a specific thread\n   * @param threadId The thread id\n   * @param commentId The comment id\n   * @param includeDeleted If you want to include deleted comments in the search\n   * @returns The comment or null if not found\n   */\n  getThreadComment(threadId: TCollabThread['id'], commentId: TCollabComment['id'], includeDeleted?: boolean): TCollabComment | null {\n    const index = this.getThreadIndex(threadId)\n\n    if (index === null) {\n      return null\n    }\n\n    const comments = this.getThreadComments(threadId, includeDeleted)\n\n    return comments?.find(comment => comment.id === commentId) ?? null\n  }\n\n  /**\n   * Adds a comment to a thread\n   * @param threadId The thread id\n   * @param data The comment data\n   * @returns The updated thread or null if the thread is not found\n   * @example addComment('123', { content: 'Hello world', data: { author: 'Maria Doe' } })\n   */\n  addComment(threadId: TCollabThread['id'], data: Omit<TCollabComment, 'id' | 'updatedAt' | 'createdAt'>) {\n    let updatedThread: TCollabThread = {} as TCollabThread\n\n    this.document.transact(() => {\n      const thread = this.getYThread(threadId)\n\n      if (thread === null) return null\n\n      const commentMap = new Y.Map()\n      commentMap.set('id', uuidv4())\n      commentMap.set('createdAt', (new Date()).toISOString())\n      thread.get('comments').push([commentMap])\n\n      this.updateComment(threadId, String(commentMap.get('id')), data)\n\n      updatedThread = thread.toJSON() as TCollabThread\n    })\n\n    return updatedThread\n  }\n\n  /**\n   * Update a comment in a thread\n   * @param threadId The thread id\n   * @param commentId The comment id\n   * @param data The new comment data\n   * @returns The updated thread or null if the thread or comment is not found\n   * @example updateComment('123', { content: 'The new content', data: { attachments: ['file1.jpg'] }})\n   */\n  updateComment(threadId: TCollabThread['id'], commentId: TCollabComment['id'], data: Partial<Pick<TCollabComment, 'data' | 'content'>>) {\n    let updatedThread: TCollabThread = {} as TCollabThread\n\n    this.document.transact(() => {\n      const thread = this.getYThread(threadId)\n\n      if (thread === null) return null\n\n      let comment = null\n      // eslint-disable-next-line no-restricted-syntax\n      for (const c of thread.get('comments')) {\n        if (c.get('id') === commentId) {\n          comment = c\n          break\n        }\n      }\n\n      if (comment === null) return null\n\n      comment.set('updatedAt', (new Date()).toISOString())\n\n      if (data.data) {\n        comment.set('data', data.data)\n      }\n\n      if (data.content) {\n        comment.set('content', data.content)\n      }\n\n      updatedThread = thread.toJSON() as TCollabThread\n    })\n\n    return updatedThread\n  }\n\n  /**\n   * Deletes a comment from a thread\n   * @param threadId The thread id\n   * @param commentId The comment id\n   * @param options A set of options that control how the comment is deleted\n   * @returns The updated thread or null if the thread or comment is not found\n   */\n  deleteComment(threadId: TCollabThread['id'], commentId: TCollabComment['id'], options?: DeleteCommentOptions) {\n    const { deleteContent, deleteThread } = { ...defaultDeleteCommentOptions, ...options }\n\n    const thread = this.getYThread(threadId)\n\n    if (thread === null) return null\n\n    let commentIndex = 0\n    // eslint-disable-next-line no-restricted-syntax\n    for (const c of thread.get('comments')) {\n      if (c.get('id') === commentId) {\n        break\n      }\n      commentIndex += 1\n    }\n\n    // if the first comment of a thread is deleted we also\n    // delete the thread itself as the source comment is gone\n    if (commentIndex === 0 && (deleteThread || (this.configuration as TiptapCollabProviderConfiguration).deleteThreadOnFirstCommentDelete)) {\n      this.deleteThread(threadId)\n      return\n    }\n\n    const comment = thread.get('comments').get(commentIndex)\n    const newComment = new Y.Map()\n\n    newComment.set('id', comment.get('id'))\n    newComment.set('createdAt', comment.get('createdAt'))\n    newComment.set('updatedAt', (new Date()).toISOString())\n    newComment.set('deletedAt', (new Date()).toISOString())\n    newComment.set('data', comment.get('data'))\n    newComment.set('content', deleteContent ? null : comment.get('content'))\n\n    if (!thread.get('deletedComments')) {\n      thread.set('deletedComments', new Y.Array())\n    }\n    thread.get('deletedComments').push([newComment])\n\n    thread.get('comments').delete(commentIndex)\n\n    return thread.toJSON() as TCollabThread\n  }\n\n  /**\n   * Start watching threads for changes\n   * @param callback The callback function to be called when a thread changes\n   */\n  watchThreads(callback: () => void) {\n    this.getYThreads().observeDeep(callback)\n  }\n\n  /**\n   * Stop watching threads for changes\n   * @param callback The callback function to be removed\n   */\n  unwatchThreads(callback: () => void) {\n    this.getYThreads().unobserveDeep(callback)\n  }\n\n}\n"],
  "mappings": "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",
  "names": ["binary.BITS7", "binary.BIT8", "math.floor", "string.utf8TextEncoder", "string.encodeUtf8", "math.min", "math.max", "error.create", "number.MAX_SAFE_INTEGER", "string.utf8TextDecoder", "AuthMessageType", "encoding.writeVarUint", "encoding.writeVarString", "decoding.readVarUint", "decoding.readVarString", "WsReadyStates", "min", "max", "create", "map", "_encodeUtf8Polyfill", "utf8TextEncoder", "_encodeUtf8Native", "encodeUtf8", "utf8TextDecoder", "length", "object.length", "object.hasProperty", "map.create", "string.fromCamelCase", "conditions.undefinedToNull", "storage.varStorage", "f.isOneOf", "floor", "min", "max", "BIT8", "BITS7", "MAX_SAFE_INTEGER", "write", "writeVarUint", "binary.BITS7", "binary.BIT8", "math.floor", "_strBuffer", "_maxStrBSize", "_writeVarStringNative", "string.utf8TextEncoder", "writeVarUint8Array", "string.encodeUtf8", "_writeVarStringPolyfill", "writeVarString", "writeUint8Array", "math.min", "math.max", "errorUnexpectedEndOfArray", "error.create", "errorIntegerOutOfRange", "readUint8Array", "readVarUint8Array", "readVarUint", "readUint8", "number.MAX_SAFE_INTEGER", "binary.BITS6", "binary.BIT7", "_readVarStringPolyfill", "_readVarStringNative", "string.utf8TextDecoder", "readVarString", "string.fromCharCode", "env.isBrowser", "buffer.fromBase64", "storage.onChange", "buffer.toBase64", "buffer.createUint8ArrayFromArrayBuffer", "storage.offChange", "map.setIfUndefined", "set.create", "array.from", "time.getUnixTime", "f.equalityDeep", "encoding.createEncoder", "encoding.writeVarUint", "encoding.writeVarString", "encoding.toUint8Array", "decoding.createDecoder", "decoding.readVarUint", "decoding.readVarString", "params", "object.map", "MessageType", "WebSocketStatus", "retryPromise", "url.encodeQueryParams", "encoding.writeVarUint8Array", "decoding.readVarUint8Array", "awarenessProtocol.applyAwarenessUpdate", "awarenessProtocol.encodeAwarenessUpdate", "bc.publish", "syncProtocol.writeSyncStep1", "syncProtocol.writeSyncStep2", "mutex.createMutex", "bc.subscribe", "bc.unsubscribe"]
}
