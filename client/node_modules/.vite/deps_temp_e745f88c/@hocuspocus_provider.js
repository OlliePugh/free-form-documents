import {
  Doc,
  PermanentUserData,
  YArray,
  YMap,
  applyUpdate,
  encodeStateAsUpdate,
  encodeStateVector
} from "./chunk-BWO4WQYY.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js
var floor = Math.floor;
var min = (a, b) => a < b ? a : b;
var max = (a, b) => a > b ? a : b;
var BIT8 = 128;
var BITS7 = 127;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var create = (s) => new Error(s);
var errorUnexpectedEndOfArray = create("Unexpected end of array");
var errorIntegerOutOfRange = create("Integer out of Range");
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var AuthMessageType;
(function(AuthMessageType2) {
  AuthMessageType2[AuthMessageType2["Token"] = 0] = "Token";
  AuthMessageType2[AuthMessageType2["PermissionDenied"] = 1] = "PermissionDenied";
  AuthMessageType2[AuthMessageType2["Authenticated"] = 2] = "Authenticated";
})(AuthMessageType || (AuthMessageType = {}));
var writeAuthentication = (encoder, auth) => {
  writeVarUint(encoder, AuthMessageType.Token);
  writeVarString(encoder, auth);
};
var readAuthMessage = (decoder, permissionDeniedHandler, authenticatedHandler) => {
  switch (readVarUint(decoder)) {
    case AuthMessageType.PermissionDenied: {
      permissionDeniedHandler(readVarString(decoder));
      break;
    }
    case AuthMessageType.Authenticated: {
      authenticatedHandler(readVarString(decoder));
      break;
    }
  }
};
var MessageTooBig = {
  code: 1009,
  reason: "Message Too Big"
};
var Unauthorized = {
  code: 4401,
  reason: "Unauthorized"
};
var Forbidden = {
  code: 4403,
  reason: "Forbidden"
};
var awarenessStatesToArray = (states) => {
  return Array.from(states.entries()).map(([key, value]) => {
    return {
      clientId: key,
      ...value
    };
  });
};
var WsReadyStates;
(function(WsReadyStates2) {
  WsReadyStates2[WsReadyStates2["Connecting"] = 0] = "Connecting";
  WsReadyStates2[WsReadyStates2["Open"] = 1] = "Open";
  WsReadyStates2[WsReadyStates2["Closing"] = 2] = "Closing";
  WsReadyStates2[WsReadyStates2["Closed"] = 3] = "Closed";
})(WsReadyStates || (WsReadyStates = {}));

// node_modules/@lifeomic/attempt/dist/es6/src/index.js
function applyDefaults(options) {
  if (!options) {
    options = {};
  }
  return {
    delay: options.delay === void 0 ? 200 : options.delay,
    initialDelay: options.initialDelay === void 0 ? 0 : options.initialDelay,
    minDelay: options.minDelay === void 0 ? 0 : options.minDelay,
    maxDelay: options.maxDelay === void 0 ? 0 : options.maxDelay,
    factor: options.factor === void 0 ? 0 : options.factor,
    maxAttempts: options.maxAttempts === void 0 ? 3 : options.maxAttempts,
    timeout: options.timeout === void 0 ? 0 : options.timeout,
    jitter: options.jitter === true,
    initialJitter: options.initialJitter === true,
    handleError: options.handleError === void 0 ? null : options.handleError,
    handleTimeout: options.handleTimeout === void 0 ? null : options.handleTimeout,
    beforeAttempt: options.beforeAttempt === void 0 ? null : options.beforeAttempt,
    calculateDelay: options.calculateDelay === void 0 ? null : options.calculateDelay
  };
}
async function sleep(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function defaultCalculateDelay(context, options) {
  let delay = options.delay;
  if (delay === 0) {
    return 0;
  }
  if (options.factor) {
    delay *= Math.pow(options.factor, context.attemptNum - 1);
    if (options.maxDelay !== 0) {
      delay = Math.min(delay, options.maxDelay);
    }
  }
  if (options.jitter) {
    const min3 = Math.ceil(options.minDelay);
    const max3 = Math.floor(delay);
    delay = Math.floor(Math.random() * (max3 - min3 + 1)) + min3;
  }
  return Math.round(delay);
}
async function retry(attemptFunc, attemptOptions) {
  const options = applyDefaults(attemptOptions);
  for (const prop of [
    "delay",
    "initialDelay",
    "minDelay",
    "maxDelay",
    "maxAttempts",
    "timeout"
  ]) {
    const value = options[prop];
    if (!Number.isInteger(value) || value < 0) {
      throw new Error(`Value for ${prop} must be an integer greater than or equal to 0`);
    }
  }
  if (options.factor.constructor !== Number || options.factor < 0) {
    throw new Error(`Value for factor must be a number greater than or equal to 0`);
  }
  if (options.delay < options.minDelay) {
    throw new Error(`delay cannot be less than minDelay (delay: ${options.delay}, minDelay: ${options.minDelay}`);
  }
  const context = {
    attemptNum: 0,
    attemptsRemaining: options.maxAttempts ? options.maxAttempts : -1,
    aborted: false,
    abort() {
      context.aborted = true;
    }
  };
  const calculateDelay = options.calculateDelay || defaultCalculateDelay;
  async function makeAttempt() {
    if (options.beforeAttempt) {
      options.beforeAttempt(context, options);
    }
    if (context.aborted) {
      const err = new Error(`Attempt aborted`);
      err.code = "ATTEMPT_ABORTED";
      throw err;
    }
    const onError = async (err) => {
      if (options.handleError) {
        await options.handleError(err, context, options);
      }
      if (context.aborted || context.attemptsRemaining === 0) {
        throw err;
      }
      context.attemptNum++;
      const delay = calculateDelay(context, options);
      if (delay) {
        await sleep(delay);
      }
      return makeAttempt();
    };
    if (context.attemptsRemaining > 0) {
      context.attemptsRemaining--;
    }
    if (options.timeout) {
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          if (options.handleTimeout) {
            try {
              resolve(options.handleTimeout(context, options));
            } catch (e) {
              reject(e);
            }
          } else {
            const err = new Error(`Retry timeout (attemptNum: ${context.attemptNum}, timeout: ${options.timeout})`);
            err.code = "ATTEMPT_TIMEOUT";
            reject(err);
          }
        }, options.timeout);
        attemptFunc(context, options).then((result) => {
          clearTimeout(timer);
          resolve(result);
        }).catch((err) => {
          clearTimeout(timer);
          onError(err).then(resolve).catch(reject);
        });
      });
    } else {
      return attemptFunc(context, options).catch(onError);
    }
  }
  const initialDelay = options.calculateDelay ? options.calculateDelay(context, options) : options.initialDelay;
  if (initialDelay) {
    await sleep(initialDelay);
  }
  if (context.attemptNum < 1 && options.initialJitter) {
    const delay = calculateDelay(context, options);
    if (delay) {
      await sleep(delay);
    }
  }
  return makeAttempt();
}

// node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js
var create$2 = () => /* @__PURE__ */ new Map();
var setIfUndefined = (map2, key, createT) => {
  let set = map2.get(key);
  if (set === void 0) {
    map2.set(key, set = createT());
  }
  return set;
};
var create$1 = () => /* @__PURE__ */ new Set();
var from = Array.from;
var fromCharCode = String.fromCharCode;
var toLowerCase = (s) => s.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s) => s.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var _encodeUtf8Polyfill2 = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder2 = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native2 = (str) => utf8TextEncoder2.encode(str);
var encodeUtf82 = utf8TextEncoder2 ? _encodeUtf8Native2 : _encodeUtf8Polyfill2;
var utf8TextDecoder2 = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder2 && utf8TextDecoder2.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder2 = null;
}
var undefinedToNull = (v) => v === void 0 ? null : v;
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;
var onChange = (eventHandler) => usePolyfill || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var offChange = (eventHandler) => usePolyfill || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var keys = Object.keys;
var map = (obj, f) => {
  const results = [];
  for (const key in obj) {
    results.push(f(obj[key], key));
  }
  return results;
};
var length$1 = (obj) => keys(obj).length;
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalityStrict = (a, b) => a === b;
var equalityDeep = (a, b) => {
  if (a == null || b == null) {
    return equalityStrict(a, b);
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a === b) {
    return true;
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case Uint8Array: {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b.size) {
        return false;
      }
      for (const value of a) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b.size) {
        return false;
      }
      for (const key of a.keys()) {
        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length$1(a) !== length$1(b)) {
        return false;
      }
      for (const key in a) {
        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalityDeep(a[i], b[i])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create$2();
      const pargs = process.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create$2();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create$2();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase()]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
!hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));
var floor2 = Math.floor;
var min2 = (a, b) => a < b ? a : b;
var max2 = (a, b) => a > b ? a : b;
var BIT7 = 64;
var BIT82 = 128;
var BITS6 = 63;
var BITS72 = 127;
var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER;
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d = encoder.bufs[i];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var write2 = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeVarUint2 = (encoder, num) => {
  while (num > BITS72) {
    write2(encoder, BIT82 | BITS72 & num);
    num = floor2(num / 128);
  }
  write2(encoder, BITS72 & num);
};
var _strBuffer2 = new Uint8Array(3e4);
var _maxStrBSize2 = _strBuffer2.length / 3;
var _writeVarStringNative2 = (encoder, str) => {
  if (str.length < _maxStrBSize2) {
    const written = utf8TextEncoder2.encodeInto(str, _strBuffer2).written || 0;
    writeVarUint2(encoder, written);
    for (let i = 0; i < written; i++) {
      write2(encoder, _strBuffer2[i]);
    }
  } else {
    writeVarUint8Array2(encoder, encodeUtf82(str));
  }
};
var _writeVarStringPolyfill2 = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint2(encoder, len);
  for (let i = 0; i < len; i++) {
    write2(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
var writeVarString2 = utf8TextEncoder2 && /** @type {any} */
utf8TextEncoder2.encodeInto ? _writeVarStringNative2 : _writeVarStringPolyfill2;
var writeUint8Array2 = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min2(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max2(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array2 = (encoder, uint8Array) => {
  writeVarUint2(encoder, uint8Array.byteLength);
  writeUint8Array2(encoder, uint8Array);
};
var create2 = (s) => new Error(s);
var errorUnexpectedEndOfArray2 = create2("Unexpected end of array");
var errorIntegerOutOfRange2 = create2("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var readUint8Array2 = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array2 = (decoder) => readUint8Array2(decoder, readVarUint2(decoder));
var readUint82 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint2 = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS72) * mult;
    mult *= 128;
    if (r < BIT82) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER2) {
      throw errorIntegerOutOfRange2;
    }
  }
  throw errorUnexpectedEndOfArray2;
};
var readVarInt = (decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT82) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS72) * mult;
    mult *= 128;
    if (r < BIT82) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER2) {
      throw errorIntegerOutOfRange2;
    }
  }
  throw errorUnexpectedEndOfArray2;
};
var _readVarStringPolyfill2 = (decoder) => {
  let remainingLen = readVarUint2(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint82(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint82(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative2 = (decoder) => (
  /** @type any */
  utf8TextDecoder2.decode(readVarUint8Array2(decoder))
);
var readVarString2 = utf8TextDecoder2 ? _readVarStringNative2 : _readVarStringPolyfill2;
var peekVarString = (decoder) => {
  const pos = decoder.pos;
  const s = readVarString2(decoder);
  decoder.pos = pos;
  return s;
};
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length2) => new Uint8Array(buffer, byteOffset, length2);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    s += fromCharCode(bytes[i]);
  }
  return btoa(s);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s) => {
  const a = atob(s);
  const bytes = createUint8ArrayFromLen(a.length);
  for (let i = 0; i < a.length; i++) {
    bytes[i] = a.charCodeAt(i);
  }
  return bytes;
};
var fromBase64Node = (s) => {
  const buf = Buffer.from(s, "base64");
  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  /**
   * @param {string} room
   */
  constructor(room) {
    this.room = room;
    this.onmessage = null;
    this._onChange = (e) => e.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e.newValue || "") });
    onChange(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(buf) {
    varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
  close() {
    offChange(this._onChange);
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room) => setIfUndefined(channels, room, () => {
  const subs = create$1();
  const bc = new BC(room);
  bc.onmessage = (e) => subs.forEach((sub) => sub(e.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe = (room, f) => {
  getChannel(room).subs.add(f);
  return f;
};
var unsubscribe = (room, f) => {
  const channel = getChannel(room);
  const unsubscribed = channel.subs.delete(f);
  if (unsubscribed && channel.subs.size === 0) {
    channel.bc.close();
    channels.delete(room);
  }
  return unsubscribed;
};
var publish = (room, data, origin = null) => {
  const c = getChannel(room);
  c.bc.postMessage(data);
  c.subs.forEach((sub) => sub(data, origin));
};
var createMutex = () => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
};
var getUnixTime = Date.now;
var Observable = class {
  constructor() {
    this._observers = create$2();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create$1).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args) => {
      this.off(name, _f);
      f(...args);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args) {
    return from((this._observers.get(name) || create$2()).values()).forEach((f) => f(...args));
  }
  destroy() {
    this._observers = create$2();
  }
};
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc) {
    super();
    this.doc = doc;
    this.clientID = doc.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor2(outdatedTimeout / 10));
    doc.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder = createEncoder();
  writeVarUint2(encoder, len);
  for (let i = 0; i < len; i++) {
    const clientID = clients[i];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint2(encoder, clientID);
    writeVarUint2(encoder, clock);
    writeVarString2(encoder, JSON.stringify(state));
  }
  return toUint8Array(encoder);
};
var applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = createDecoder(update);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint2(decoder);
  for (let i = 0; i < len; i++) {
    const clientID = readVarUint2(decoder);
    let clock = readVarUint2(decoder);
    const state = JSON.parse(readVarString2(decoder));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
var encodeQueryParams = (params2) => map(params2, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join("&");
var MessageType;
(function(MessageType2) {
  MessageType2[MessageType2["Sync"] = 0] = "Sync";
  MessageType2[MessageType2["Awareness"] = 1] = "Awareness";
  MessageType2[MessageType2["Auth"] = 2] = "Auth";
  MessageType2[MessageType2["QueryAwareness"] = 3] = "QueryAwareness";
  MessageType2[MessageType2["Stateless"] = 5] = "Stateless";
  MessageType2[MessageType2["CLOSE"] = 7] = "CLOSE";
  MessageType2[MessageType2["SyncStatus"] = 8] = "SyncStatus";
})(MessageType || (MessageType = {}));
var WebSocketStatus;
(function(WebSocketStatus2) {
  WebSocketStatus2["Connecting"] = "connecting";
  WebSocketStatus2["Connected"] = "connected";
  WebSocketStatus2["Disconnected"] = "disconnected";
})(WebSocketStatus || (WebSocketStatus = {}));
var IncomingMessage = class {
  constructor(data) {
    this.data = data;
    this.encoder = createEncoder();
    this.decoder = createDecoder(new Uint8Array(this.data));
  }
  peekVarString() {
    return peekVarString(this.decoder);
  }
  readVarUint() {
    return readVarUint2(this.decoder);
  }
  readVarString() {
    return readVarString2(this.decoder);
  }
  readVarUint8Array() {
    return readVarUint8Array2(this.decoder);
  }
  writeVarUint(type) {
    return writeVarUint2(this.encoder, type);
  }
  writeVarString(string) {
    return writeVarString2(this.encoder, string);
  }
  writeVarUint8Array(data) {
    return writeVarUint8Array2(this.encoder, data);
  }
  length() {
    return length(this.encoder);
  }
};
var HocuspocusProviderWebsocket = class extends EventEmitter {
  constructor(configuration) {
    super();
    this.messageQueue = [];
    this.configuration = {
      url: "",
      // @ts-ignore
      document: void 0,
      WebSocketPolyfill: void 0,
      parameters: {},
      connect: true,
      broadcast: true,
      forceSyncInterval: false,
      // TODO: this should depend on awareness.outdatedTime
      messageReconnectTimeout: 3e4,
      // 1 second
      delay: 1e3,
      // instant
      initialDelay: 0,
      // double the delay each time
      factor: 2,
      // unlimited retries
      maxAttempts: 0,
      // wait at least 1 second
      minDelay: 1e3,
      // at least every 30 seconds
      maxDelay: 3e4,
      // randomize
      jitter: true,
      // retry forever
      timeout: 0,
      onOpen: () => null,
      onConnect: () => null,
      onMessage: () => null,
      onOutgoingMessage: () => null,
      onStatus: () => null,
      onDisconnect: () => null,
      onClose: () => null,
      onDestroy: () => null,
      onAwarenessUpdate: () => null,
      onAwarenessChange: () => null,
      quiet: false,
      providerMap: /* @__PURE__ */ new Map()
    };
    this.webSocket = null;
    this.webSocketHandlers = {};
    this.shouldConnect = true;
    this.status = WebSocketStatus.Disconnected;
    this.lastMessageReceived = 0;
    this.identifier = 0;
    this.intervals = {
      forceSync: null,
      connectionChecker: null
    };
    this.connectionAttempt = null;
    this.receivedOnOpenPayload = void 0;
    this.receivedOnStatusPayload = void 0;
    this.closeTries = 0;
    this.setConfiguration(configuration);
    this.configuration.WebSocketPolyfill = configuration.WebSocketPolyfill ? configuration.WebSocketPolyfill : WebSocket;
    this.on("open", this.configuration.onOpen);
    this.on("open", this.onOpen.bind(this));
    this.on("connect", this.configuration.onConnect);
    this.on("message", this.configuration.onMessage);
    this.on("outgoingMessage", this.configuration.onOutgoingMessage);
    this.on("status", this.configuration.onStatus);
    this.on("status", this.onStatus.bind(this));
    this.on("disconnect", this.configuration.onDisconnect);
    this.on("close", this.configuration.onClose);
    this.on("destroy", this.configuration.onDestroy);
    this.on("awarenessUpdate", this.configuration.onAwarenessUpdate);
    this.on("awarenessChange", this.configuration.onAwarenessChange);
    this.on("close", this.onClose.bind(this));
    this.on("message", this.onMessage.bind(this));
    this.intervals.connectionChecker = setInterval(this.checkConnection.bind(this), this.configuration.messageReconnectTimeout / 10);
    if (typeof configuration.connect !== "undefined") {
      this.shouldConnect = configuration.connect;
    }
    if (!this.shouldConnect) {
      return;
    }
    this.connect();
  }
  async onOpen(event) {
    this.receivedOnOpenPayload = event;
  }
  async onStatus(data) {
    this.receivedOnStatusPayload = data;
  }
  attach(provider) {
    let connectPromise;
    this.configuration.providerMap.set(provider.configuration.name, provider);
    if (this.status === WebSocketStatus.Disconnected && this.shouldConnect) {
      connectPromise = this.connect();
    }
    if (this.receivedOnOpenPayload) {
      provider.onOpen(this.receivedOnOpenPayload);
    }
    if (this.receivedOnStatusPayload) {
      provider.onStatus(this.receivedOnStatusPayload);
    }
    return connectPromise;
  }
  detach(provider) {
    this.configuration.providerMap.delete(provider.configuration.name);
  }
  setConfiguration(configuration = {}) {
    this.configuration = { ...this.configuration, ...configuration };
  }
  async connect() {
    if (this.status === WebSocketStatus.Connected) {
      return;
    }
    if (this.cancelWebsocketRetry) {
      this.cancelWebsocketRetry();
      this.cancelWebsocketRetry = void 0;
    }
    this.receivedOnOpenPayload = void 0;
    this.receivedOnStatusPayload = void 0;
    this.shouldConnect = true;
    const abortableRetry = () => {
      let cancelAttempt = false;
      const retryPromise2 = retry(this.createWebSocketConnection.bind(this), {
        delay: this.configuration.delay,
        initialDelay: this.configuration.initialDelay,
        factor: this.configuration.factor,
        maxAttempts: this.configuration.maxAttempts,
        minDelay: this.configuration.minDelay,
        maxDelay: this.configuration.maxDelay,
        jitter: this.configuration.jitter,
        timeout: this.configuration.timeout,
        beforeAttempt: (context) => {
          if (!this.shouldConnect || cancelAttempt) {
            context.abort();
          }
        }
      }).catch((error) => {
        if (error && error.code !== "ATTEMPT_ABORTED") {
          throw error;
        }
      });
      return {
        retryPromise: retryPromise2,
        cancelFunc: () => {
          cancelAttempt = true;
        }
      };
    };
    const { retryPromise, cancelFunc } = abortableRetry();
    this.cancelWebsocketRetry = cancelFunc;
    return retryPromise;
  }
  attachWebSocketListeners(ws, reject) {
    const { identifier } = ws;
    const onMessageHandler = (payload) => this.emit("message", payload);
    const onCloseHandler = (payload) => this.emit("close", { event: payload });
    const onOpenHandler = (payload) => this.emit("open", payload);
    const onErrorHandler = (err) => {
      reject(err);
    };
    this.webSocketHandlers[identifier] = {
      message: onMessageHandler,
      close: onCloseHandler,
      open: onOpenHandler,
      error: onErrorHandler
    };
    const handlers = this.webSocketHandlers[ws.identifier];
    Object.keys(handlers).forEach((name) => {
      ws.addEventListener(name, handlers[name]);
    });
  }
  cleanupWebSocket() {
    if (!this.webSocket) {
      return;
    }
    const { identifier } = this.webSocket;
    const handlers = this.webSocketHandlers[identifier];
    Object.keys(handlers).forEach((name) => {
      var _a;
      (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.removeEventListener(name, handlers[name]);
      delete this.webSocketHandlers[identifier];
    });
    this.webSocket.close();
    this.webSocket = null;
  }
  createWebSocketConnection() {
    return new Promise((resolve, reject) => {
      if (this.webSocket) {
        this.messageQueue = [];
        this.cleanupWebSocket();
      }
      this.lastMessageReceived = 0;
      this.identifier += 1;
      const ws = new this.configuration.WebSocketPolyfill(this.url);
      ws.binaryType = "arraybuffer";
      ws.identifier = this.identifier;
      this.attachWebSocketListeners(ws, reject);
      this.webSocket = ws;
      this.status = WebSocketStatus.Connecting;
      this.emit("status", { status: WebSocketStatus.Connecting });
      this.connectionAttempt = {
        resolve,
        reject
      };
    });
  }
  onMessage(event) {
    var _a;
    this.resolveConnectionAttempt();
    this.lastMessageReceived = getUnixTime();
    const message = new IncomingMessage(event.data);
    const documentName = message.peekVarString();
    (_a = this.configuration.providerMap.get(documentName)) === null || _a === void 0 ? void 0 : _a.onMessage(event);
  }
  resolveConnectionAttempt() {
    if (this.connectionAttempt) {
      this.connectionAttempt.resolve();
      this.connectionAttempt = null;
      this.status = WebSocketStatus.Connected;
      this.emit("status", { status: WebSocketStatus.Connected });
      this.emit("connect");
      this.messageQueue.forEach((message) => this.send(message));
      this.messageQueue = [];
    }
  }
  stopConnectionAttempt() {
    this.connectionAttempt = null;
  }
  rejectConnectionAttempt() {
    var _a;
    (_a = this.connectionAttempt) === null || _a === void 0 ? void 0 : _a.reject();
    this.connectionAttempt = null;
  }
  checkConnection() {
    var _a;
    if (this.status !== WebSocketStatus.Connected) {
      return;
    }
    if (!this.lastMessageReceived) {
      return;
    }
    if (this.configuration.messageReconnectTimeout >= getUnixTime() - this.lastMessageReceived) {
      return;
    }
    this.closeTries += 1;
    if (this.closeTries > 2) {
      this.onClose({
        event: {
          code: 4408,
          reason: "forced"
        }
      });
      this.closeTries = 0;
    } else {
      (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.close();
      this.messageQueue = [];
    }
  }
  // Ensure that the URL always ends with /
  get serverUrl() {
    while (this.configuration.url[this.configuration.url.length - 1] === "/") {
      return this.configuration.url.slice(0, this.configuration.url.length - 1);
    }
    return this.configuration.url;
  }
  get url() {
    const encodedParams = encodeQueryParams(this.configuration.parameters);
    return `${this.serverUrl}${encodedParams.length === 0 ? "" : `?${encodedParams}`}`;
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.webSocket === null) {
      return;
    }
    try {
      this.webSocket.close();
      this.messageQueue = [];
    } catch {
    }
  }
  send(message) {
    var _a;
    if (((_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.readyState) === WsReadyStates.Open) {
      this.webSocket.send(message);
    } else {
      this.messageQueue.push(message);
    }
  }
  onClose({ event }) {
    this.closeTries = 0;
    this.cleanupWebSocket();
    if (this.status === WebSocketStatus.Connected) {
      this.status = WebSocketStatus.Disconnected;
      this.emit("status", { status: WebSocketStatus.Disconnected });
      this.emit("disconnect", { event });
    }
    if (event.code === Unauthorized.code) {
      if (event.reason === Unauthorized.reason) {
        console.warn("[HocuspocusProvider] An authentication token is required, but you didn’t send one. Try adding a `token` to your HocuspocusProvider configuration. Won’t try again.");
      } else {
        console.warn(`[HocuspocusProvider] Connection closed with status Unauthorized: ${event.reason}`);
      }
      this.shouldConnect = false;
    }
    if (event.code === Forbidden.code) {
      if (!this.configuration.quiet) {
        console.warn("[HocuspocusProvider] The provided authentication token isn’t allowed to connect to this server. Will try again.");
        return;
      }
    }
    if (event.code === MessageTooBig.code) {
      console.warn(`[HocuspocusProvider] Connection closed with status MessageTooBig: ${event.reason}`);
      this.shouldConnect = false;
    }
    if (this.connectionAttempt) {
      this.rejectConnectionAttempt();
    } else if (this.shouldConnect) {
      this.connect();
    }
    if (this.shouldConnect) {
      return;
    }
    if (this.status === WebSocketStatus.Disconnected) {
      return;
    }
    this.status = WebSocketStatus.Disconnected;
    this.emit("status", { status: WebSocketStatus.Disconnected });
    this.emit("disconnect", { event });
  }
  destroy() {
    this.emit("destroy");
    if (this.intervals.forceSync) {
      clearInterval(this.intervals.forceSync);
    }
    clearInterval(this.intervals.connectionChecker);
    this.stopConnectionAttempt();
    this.disconnect();
    this.removeAllListeners();
    this.cleanupWebSocket();
  }
};
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder, doc) => {
  writeVarUint2(encoder, messageYjsSyncStep1);
  const sv = encodeStateVector(doc);
  writeVarUint8Array2(encoder, sv);
};
var writeSyncStep2 = (encoder, doc, encodedStateVector) => {
  writeVarUint2(encoder, messageYjsSyncStep2);
  writeVarUint8Array2(encoder, encodeStateAsUpdate(doc, encodedStateVector));
};
var readSyncStep1 = (decoder, encoder, doc) => writeSyncStep2(encoder, doc, readVarUint8Array2(decoder));
var readSyncStep2 = (decoder, doc, transactionOrigin) => {
  try {
    applyUpdate(doc, readVarUint8Array2(decoder), transactionOrigin);
  } catch (error) {
    console.error("Caught error while handling a Yjs update", error);
  }
};
var writeUpdate = (encoder, update) => {
  writeVarUint2(encoder, messageYjsUpdate);
  writeVarUint8Array2(encoder, update);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {
  const messageType = readVarUint2(decoder);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder, doc, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};
var OutgoingMessage = class {
  constructor() {
    this.encoder = createEncoder();
  }
  get(args) {
    return args.encoder;
  }
  toUint8Array() {
    return toUint8Array(this.encoder);
  }
};
var MessageReceiver = class {
  constructor(message) {
    this.broadcasted = false;
    this.message = message;
  }
  setBroadcasted(value) {
    this.broadcasted = value;
    return this;
  }
  apply(provider, emitSynced) {
    const { message } = this;
    const type = message.readVarUint();
    const emptyMessageLength = message.length();
    switch (type) {
      case MessageType.Sync:
        this.applySyncMessage(provider, emitSynced);
        break;
      case MessageType.Awareness:
        this.applyAwarenessMessage(provider);
        break;
      case MessageType.Auth:
        this.applyAuthMessage(provider);
        break;
      case MessageType.QueryAwareness:
        this.applyQueryAwarenessMessage(provider);
        break;
      case MessageType.Stateless:
        provider.receiveStateless(readVarString2(message.decoder));
        break;
      case MessageType.SyncStatus:
        this.applySyncStatusMessage(provider, readVarInt(message.decoder) === 1);
        break;
      default:
        throw new Error(`Can’t apply message of unknown type: ${type}`);
    }
    if (message.length() > emptyMessageLength + 1) {
      if (this.broadcasted) {
        provider.broadcast(OutgoingMessage, { encoder: message.encoder });
      } else {
        provider.send(OutgoingMessage, { encoder: message.encoder });
      }
    }
  }
  applySyncMessage(provider, emitSynced) {
    const { message } = this;
    message.writeVarUint(MessageType.Sync);
    const syncMessageType = readSyncMessage(message.decoder, message.encoder, provider.document, provider);
    if (emitSynced && syncMessageType === messageYjsSyncStep2) {
      provider.synced = true;
    }
  }
  applySyncStatusMessage(provider, applied) {
    if (applied) {
      provider.decrementUnsyncedChanges();
    }
  }
  applyAwarenessMessage(provider) {
    if (!provider.awareness)
      return;
    const { message } = this;
    applyAwarenessUpdate(provider.awareness, message.readVarUint8Array(), provider);
  }
  applyAuthMessage(provider) {
    const { message } = this;
    readAuthMessage(message.decoder, provider.permissionDeniedHandler.bind(provider), provider.authenticatedHandler.bind(provider));
  }
  applyQueryAwarenessMessage(provider) {
    if (!provider.awareness)
      return;
    const { message } = this;
    message.writeVarUint(MessageType.Awareness);
    message.writeVarUint8Array(encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));
  }
};
var MessageSender = class {
  constructor(Message, args = {}) {
    this.message = new Message();
    this.encoder = this.message.get(args);
  }
  create() {
    return toUint8Array(this.encoder);
  }
  send(webSocket) {
    webSocket === null || webSocket === void 0 ? void 0 : webSocket.send(this.create());
  }
  broadcast(channel) {
    publish(channel, this.create());
  }
};
var AuthenticationMessage = class extends OutgoingMessage {
  constructor() {
    super(...arguments);
    this.type = MessageType.Auth;
    this.description = "Authentication";
  }
  get(args) {
    if (typeof args.token === "undefined") {
      throw new Error("The authentication message requires `token` as an argument.");
    }
    writeVarString2(this.encoder, args.documentName);
    writeVarUint2(this.encoder, this.type);
    writeAuthentication(this.encoder, args.token);
    return this.encoder;
  }
};
var AwarenessMessage = class extends OutgoingMessage {
  constructor() {
    super(...arguments);
    this.type = MessageType.Awareness;
    this.description = "Awareness states update";
  }
  get(args) {
    if (typeof args.awareness === "undefined") {
      throw new Error("The awareness message requires awareness as an argument");
    }
    if (typeof args.clients === "undefined") {
      throw new Error("The awareness message requires clients as an argument");
    }
    writeVarString2(this.encoder, args.documentName);
    writeVarUint2(this.encoder, this.type);
    let awarenessUpdate;
    if (args.states === void 0) {
      awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients);
    } else {
      awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients, args.states);
    }
    writeVarUint8Array2(this.encoder, awarenessUpdate);
    return this.encoder;
  }
};
var CloseMessage = class extends OutgoingMessage {
  constructor() {
    super(...arguments);
    this.type = MessageType.CLOSE;
    this.description = "Ask the server to close the connection";
  }
  get(args) {
    writeVarString2(this.encoder, args.documentName);
    writeVarUint2(this.encoder, this.type);
    return this.encoder;
  }
};
var QueryAwarenessMessage = class extends OutgoingMessage {
  constructor() {
    super(...arguments);
    this.type = MessageType.QueryAwareness;
    this.description = "Queries awareness states";
  }
  get(args) {
    writeVarString2(this.encoder, args.documentName);
    writeVarUint2(this.encoder, this.type);
    return this.encoder;
  }
};
var StatelessMessage = class extends OutgoingMessage {
  constructor() {
    super(...arguments);
    this.type = MessageType.Stateless;
    this.description = "A stateless message";
  }
  get(args) {
    var _a;
    writeVarString2(this.encoder, args.documentName);
    writeVarUint2(this.encoder, this.type);
    writeVarString2(this.encoder, (_a = args.payload) !== null && _a !== void 0 ? _a : "");
    return this.encoder;
  }
};
var SyncStepOneMessage = class extends OutgoingMessage {
  constructor() {
    super(...arguments);
    this.type = MessageType.Sync;
    this.description = "First sync step";
  }
  get(args) {
    if (typeof args.document === "undefined") {
      throw new Error("The sync step one message requires document as an argument");
    }
    writeVarString2(this.encoder, args.documentName);
    writeVarUint2(this.encoder, this.type);
    writeSyncStep1(this.encoder, args.document);
    return this.encoder;
  }
};
var SyncStepTwoMessage = class extends OutgoingMessage {
  constructor() {
    super(...arguments);
    this.type = MessageType.Sync;
    this.description = "Second sync step";
  }
  get(args) {
    if (typeof args.document === "undefined") {
      throw new Error("The sync step two message requires document as an argument");
    }
    writeVarString2(this.encoder, args.documentName);
    writeVarUint2(this.encoder, this.type);
    writeSyncStep2(this.encoder, args.document);
    return this.encoder;
  }
};
var UpdateMessage = class extends OutgoingMessage {
  constructor() {
    super(...arguments);
    this.type = MessageType.Sync;
    this.description = "A document update";
  }
  get(args) {
    writeVarString2(this.encoder, args.documentName);
    writeVarUint2(this.encoder, this.type);
    writeUpdate(this.encoder, args.update);
    return this.encoder;
  }
};
var AwarenessError = class extends Error {
  constructor() {
    super(...arguments);
    this.code = 1001;
  }
};
var HocuspocusProvider = class extends EventEmitter {
  constructor(configuration) {
    var _a, _b, _c;
    super();
    this.configuration = {
      name: "",
      // @ts-ignore
      document: void 0,
      // @ts-ignore
      awareness: void 0,
      token: null,
      parameters: {},
      broadcast: true,
      forceSyncInterval: false,
      onAuthenticated: () => null,
      onAuthenticationFailed: () => null,
      onOpen: () => null,
      onConnect: () => null,
      onMessage: () => null,
      onOutgoingMessage: () => null,
      onStatus: () => null,
      onSynced: () => null,
      onDisconnect: () => null,
      onClose: () => null,
      onDestroy: () => null,
      onAwarenessUpdate: () => null,
      onAwarenessChange: () => null,
      onStateless: () => null,
      quiet: false,
      connect: true,
      preserveConnection: true
    };
    this.subscribedToBroadcastChannel = false;
    this.isSynced = false;
    this.unsyncedChanges = 0;
    this.status = WebSocketStatus.Disconnected;
    this.isAuthenticated = false;
    this.authorizedScope = void 0;
    this.mux = createMutex();
    this.intervals = {
      forceSync: null
    };
    this.isConnected = true;
    this.boundDocumentUpdateHandler = this.documentUpdateHandler.bind(this);
    this.boundAwarenessUpdateHandler = this.awarenessUpdateHandler.bind(this);
    this.boundBroadcastChannelSubscriber = this.broadcastChannelSubscriber.bind(this);
    this.boundPageHide = this.pageHide.bind(this);
    this.boundOnOpen = this.onOpen.bind(this);
    this.boundOnClose = this.onClose.bind(this);
    this.boundOnStatus = this.onStatus.bind(this);
    this.forwardConnect = (e) => this.emit("connect", e);
    this.forwardOpen = (e) => this.emit("open", e);
    this.forwardClose = (e) => this.emit("close", e);
    this.forwardDisconnect = (e) => this.emit("disconnect", e);
    this.forwardDestroy = (e) => this.emit("destroy", e);
    this.setConfiguration(configuration);
    this.configuration.document = configuration.document ? configuration.document : new Doc();
    this.configuration.awareness = configuration.awareness !== void 0 ? configuration.awareness : new Awareness(this.document);
    this.on("open", this.configuration.onOpen);
    this.on("message", this.configuration.onMessage);
    this.on("outgoingMessage", this.configuration.onOutgoingMessage);
    this.on("synced", this.configuration.onSynced);
    this.on("destroy", this.configuration.onDestroy);
    this.on("awarenessUpdate", this.configuration.onAwarenessUpdate);
    this.on("awarenessChange", this.configuration.onAwarenessChange);
    this.on("stateless", this.configuration.onStateless);
    this.on("authenticated", this.configuration.onAuthenticated);
    this.on("authenticationFailed", this.configuration.onAuthenticationFailed);
    this.configuration.websocketProvider.on("connect", this.configuration.onConnect);
    this.configuration.websocketProvider.on("connect", this.forwardConnect);
    this.configuration.websocketProvider.on("open", this.boundOnOpen);
    this.configuration.websocketProvider.on("open", this.forwardOpen);
    this.configuration.websocketProvider.on("close", this.boundOnClose);
    this.configuration.websocketProvider.on("close", this.configuration.onClose);
    this.configuration.websocketProvider.on("close", this.forwardClose);
    this.configuration.websocketProvider.on("status", this.boundOnStatus);
    this.configuration.websocketProvider.on("disconnect", this.configuration.onDisconnect);
    this.configuration.websocketProvider.on("disconnect", this.forwardDisconnect);
    this.configuration.websocketProvider.on("destroy", this.configuration.onDestroy);
    this.configuration.websocketProvider.on("destroy", this.forwardDestroy);
    (_a = this.awareness) === null || _a === void 0 ? void 0 : _a.on("update", () => {
      this.emit("awarenessUpdate", { states: awarenessStatesToArray(this.awareness.getStates()) });
    });
    (_b = this.awareness) === null || _b === void 0 ? void 0 : _b.on("change", () => {
      this.emit("awarenessChange", { states: awarenessStatesToArray(this.awareness.getStates()) });
    });
    this.document.on("update", this.boundDocumentUpdateHandler);
    (_c = this.awareness) === null || _c === void 0 ? void 0 : _c.on("update", this.boundAwarenessUpdateHandler);
    this.registerEventListeners();
    if (this.configuration.forceSyncInterval && typeof this.configuration.forceSyncInterval === "number") {
      this.intervals.forceSync = setInterval(this.forceSync.bind(this), this.configuration.forceSyncInterval);
    }
    this.configuration.websocketProvider.attach(this);
  }
  onStatus({ status }) {
    this.status = status;
    this.configuration.onStatus({ status });
    this.emit("status", { status });
  }
  setConfiguration(configuration = {}) {
    if (!configuration.websocketProvider && configuration.url) {
      const websocketProviderConfig = configuration;
      this.configuration.websocketProvider = new HocuspocusProviderWebsocket({
        url: websocketProviderConfig.url,
        connect: websocketProviderConfig.connect,
        parameters: websocketProviderConfig.parameters
      });
    }
    this.configuration = { ...this.configuration, ...configuration };
  }
  get document() {
    return this.configuration.document;
  }
  get awareness() {
    return this.configuration.awareness;
  }
  get hasUnsyncedChanges() {
    return this.unsyncedChanges > 0;
  }
  resetUnsyncedChanges() {
    this.unsyncedChanges = 1;
    this.emit("unsyncedChanges", this.unsyncedChanges);
  }
  incrementUnsyncedChanges() {
    this.unsyncedChanges += 1;
    this.emit("unsyncedChanges", this.unsyncedChanges);
  }
  decrementUnsyncedChanges() {
    this.unsyncedChanges -= 1;
    if (this.unsyncedChanges === 0) {
      this.synced = true;
    }
    this.emit("unsyncedChanges", this.unsyncedChanges);
  }
  forceSync() {
    this.resetUnsyncedChanges();
    this.send(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name });
  }
  pageHide() {
    if (this.awareness) {
      removeAwarenessStates(this.awareness, [this.document.clientID], "page hide");
    }
  }
  registerEventListeners() {
    if (typeof window === "undefined" || !("addEventListener" in window)) {
      return;
    }
    window.addEventListener("pagehide", this.boundPageHide);
  }
  sendStateless(payload) {
    this.send(StatelessMessage, { documentName: this.configuration.name, payload });
  }
  documentUpdateHandler(update, origin) {
    if (origin === this) {
      return;
    }
    this.incrementUnsyncedChanges();
    this.send(UpdateMessage, { update, documentName: this.configuration.name }, true);
  }
  awarenessUpdateHandler({ added, updated, removed }, origin) {
    const changedClients = added.concat(updated).concat(removed);
    this.send(AwarenessMessage, {
      awareness: this.awareness,
      clients: changedClients,
      documentName: this.configuration.name
    }, true);
  }
  /**
   * Indicates whether a first handshake with the server has been established
   *
   * Note: this does not mean all updates from the client have been persisted to the backend. For this,
   * use `hasUnsyncedChanges`.
   */
  get synced() {
    return this.isSynced;
  }
  set synced(state) {
    if (this.isSynced === state) {
      return;
    }
    this.isSynced = state;
    this.emit("synced", { state });
    this.emit("sync", { state });
  }
  receiveStateless(payload) {
    this.emit("stateless", { payload });
  }
  get isAuthenticationRequired() {
    return !!this.configuration.token && !this.isAuthenticated;
  }
  // not needed, but provides backward compatibility with e.g. lexical/yjs
  async connect() {
    if (this.configuration.broadcast) {
      this.subscribeToBroadcastChannel();
    }
    this.configuration.websocketProvider.shouldConnect = true;
    return this.configuration.websocketProvider.attach(this);
  }
  disconnect() {
    this.disconnectBroadcastChannel();
    this.configuration.websocketProvider.detach(this);
    this.isConnected = false;
    if (!this.configuration.preserveConnection) {
      this.configuration.websocketProvider.disconnect();
    }
  }
  async onOpen(event) {
    this.isAuthenticated = false;
    this.isConnected = true;
    this.emit("open", { event });
    let token;
    try {
      token = await this.getToken();
    } catch (error) {
      this.permissionDeniedHandler(`Failed to get token: ${error}`);
      return;
    }
    if (this.isAuthenticationRequired) {
      this.send(AuthenticationMessage, {
        token,
        documentName: this.configuration.name
      });
    }
    this.startSync();
  }
  async getToken() {
    if (typeof this.configuration.token === "function") {
      const token = await this.configuration.token();
      return token;
    }
    return this.configuration.token;
  }
  startSync() {
    this.resetUnsyncedChanges();
    this.send(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name });
    if (this.awareness && this.awareness.getLocalState() !== null) {
      this.send(AwarenessMessage, {
        awareness: this.awareness,
        clients: [this.document.clientID],
        documentName: this.configuration.name
      });
    }
  }
  send(message, args, broadcast = false) {
    if (!this.isConnected) {
      return;
    }
    if (broadcast) {
      this.mux(() => {
        this.broadcast(message, args);
      });
    }
    const messageSender = new MessageSender(message, args);
    this.emit("outgoingMessage", { message: messageSender.message });
    messageSender.send(this.configuration.websocketProvider);
  }
  onMessage(event) {
    const message = new IncomingMessage(event.data);
    const documentName = message.readVarString();
    message.writeVarString(documentName);
    this.emit("message", { event, message: new IncomingMessage(event.data) });
    new MessageReceiver(message).apply(this, true);
  }
  onClose(event) {
    this.isAuthenticated = false;
    this.synced = false;
    if (this.awareness) {
      removeAwarenessStates(this.awareness, Array.from(this.awareness.getStates().keys()).filter((client) => client !== this.document.clientID), this);
    }
  }
  destroy() {
    this.emit("destroy");
    if (this.intervals.forceSync) {
      clearInterval(this.intervals.forceSync);
    }
    if (this.awareness) {
      removeAwarenessStates(this.awareness, [this.document.clientID], "provider destroy");
      this.awareness.off("update", this.boundAwarenessUpdateHandler);
      this.awareness.destroy();
    }
    this.document.off("update", this.boundDocumentUpdateHandler);
    this.removeAllListeners();
    this.configuration.websocketProvider.off("connect", this.configuration.onConnect);
    this.configuration.websocketProvider.off("connect", this.forwardConnect);
    this.configuration.websocketProvider.off("open", this.boundOnOpen);
    this.configuration.websocketProvider.off("open", this.forwardOpen);
    this.configuration.websocketProvider.off("close", this.boundOnClose);
    this.configuration.websocketProvider.off("close", this.configuration.onClose);
    this.configuration.websocketProvider.off("close", this.forwardClose);
    this.configuration.websocketProvider.off("status", this.boundOnStatus);
    this.configuration.websocketProvider.off("disconnect", this.configuration.onDisconnect);
    this.configuration.websocketProvider.off("disconnect", this.forwardDisconnect);
    this.configuration.websocketProvider.off("destroy", this.configuration.onDestroy);
    this.configuration.websocketProvider.off("destroy", this.forwardDestroy);
    this.send(CloseMessage, { documentName: this.configuration.name });
    this.disconnect();
    if (typeof window === "undefined" || !("removeEventListener" in window)) {
      return;
    }
    window.removeEventListener("pagehide", this.boundPageHide);
  }
  permissionDeniedHandler(reason) {
    this.emit("authenticationFailed", { reason });
    this.isAuthenticated = false;
    this.disconnect();
    this.status = WebSocketStatus.Disconnected;
  }
  authenticatedHandler(scope) {
    this.isAuthenticated = true;
    this.authorizedScope = scope;
    this.emit("authenticated");
  }
  get broadcastChannel() {
    return `${this.configuration.name}`;
  }
  broadcastChannelSubscriber(data) {
    this.mux(() => {
      const message = new IncomingMessage(data);
      const documentName = message.readVarString();
      message.writeVarString(documentName);
      new MessageReceiver(message).setBroadcasted(true).apply(this, false);
    });
  }
  subscribeToBroadcastChannel() {
    if (!this.subscribedToBroadcastChannel) {
      subscribe(this.broadcastChannel, this.boundBroadcastChannelSubscriber);
      this.subscribedToBroadcastChannel = true;
    }
    this.mux(() => {
      this.broadcast(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name });
      this.broadcast(SyncStepTwoMessage, { document: this.document, documentName: this.configuration.name });
      this.broadcast(QueryAwarenessMessage, { document: this.document, documentName: this.configuration.name });
      if (this.awareness) {
        this.broadcast(AwarenessMessage, {
          awareness: this.awareness,
          clients: [this.document.clientID],
          document: this.document,
          documentName: this.configuration.name
        });
      }
    });
  }
  disconnectBroadcastChannel() {
    if (this.awareness) {
      this.send(AwarenessMessage, {
        awareness: this.awareness,
        clients: [this.document.clientID],
        states: /* @__PURE__ */ new Map(),
        documentName: this.configuration.name
      }, true);
    }
    if (this.subscribedToBroadcastChannel) {
      unsubscribe(this.broadcastChannel, this.boundBroadcastChannelSubscriber);
      this.subscribedToBroadcastChannel = false;
    }
  }
  broadcast(Message, args) {
    if (!this.configuration.broadcast) {
      return;
    }
    if (!this.subscribedToBroadcastChannel) {
      return;
    }
    new MessageSender(Message, args).broadcast(this.broadcastChannel);
  }
  setAwarenessField(key, value) {
    if (!this.awareness) {
      throw new AwarenessError(`Cannot set awareness field "${key}" to ${JSON.stringify(value)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`);
    }
    this.awareness.setLocalStateField(key, value);
  }
};
var getRandomValues = crypto.getRandomValues.bind(crypto);
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
);
var TiptapCollabProviderWebsocket = class extends HocuspocusProviderWebsocket {
  constructor(configuration) {
    var _a;
    let url = (_a = configuration.baseUrl) !== null && _a !== void 0 ? _a : `wss://${configuration.appId}.collab.tiptap.cloud`;
    if (configuration.shardKey) {
      url += url.includes("?") ? "&" : "?";
      url += `shard=${configuration.shardKey}`;
    }
    super({ ...configuration, url });
  }
};
var defaultDeleteCommentOptions = {
  deleteContent: false,
  deleteThread: false
};
var defaultGetThreadsOptions = {
  types: ["unarchived"]
};
var defaultDeleteThreadOptions = {
  deleteComments: false,
  force: false
};
var TiptapCollabProvider = class extends HocuspocusProvider {
  constructor(configuration) {
    if (!configuration.websocketProvider) {
      configuration.websocketProvider = new TiptapCollabProviderWebsocket({ appId: configuration.appId, baseUrl: configuration.baseUrl });
    }
    if (!configuration.token) {
      configuration.token = "notoken";
    }
    super(configuration);
    this.tiptapCollabConfigurationPrefix = "__tiptapcollab__";
    if (configuration.user) {
      this.userData = new PermanentUserData(this.document, this.document.getMap("__tiptapcollab__users"));
      this.userData.setUserMapping(this.document, this.document.clientID, configuration.user);
    }
  }
  /**
   * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.
   */
  createVersion(name) {
    return this.sendStateless(JSON.stringify({ action: "version.create", name }));
  }
  /**
   * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.
   */
  revertToVersion(targetVersion) {
    return this.sendStateless(JSON.stringify({ action: "document.revert", version: targetVersion }));
  }
  /**
   * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.
   *
   * The server will reply with a stateless message (THistoryVersionPreviewEvent)
   */
  previewVersion(targetVersion) {
    return this.sendStateless(JSON.stringify({ action: "version.preview", version: targetVersion }));
  }
  /**
   * note: this will only work if your server loaded @hocuspocus-pro/extension-history, or if you are on a Tiptap business plan.
   */
  getVersions() {
    return this.configuration.document.getArray(`${this.tiptapCollabConfigurationPrefix}versions`).toArray();
  }
  watchVersions(callback) {
    return this.configuration.document.getArray("__tiptapcollab__versions").observe(callback);
  }
  unwatchVersions(callback) {
    return this.configuration.document.getArray("__tiptapcollab__versions").unobserve(callback);
  }
  isAutoVersioning() {
    return !!this.configuration.document.getMap(`${this.tiptapCollabConfigurationPrefix}config`).get("autoVersioning");
  }
  enableAutoVersioning() {
    return this.configuration.document.getMap(`${this.tiptapCollabConfigurationPrefix}config`).set("autoVersioning", 1);
  }
  disableAutoVersioning() {
    return this.configuration.document.getMap(`${this.tiptapCollabConfigurationPrefix}config`).set("autoVersioning", 0);
  }
  /**
   * Returns all users in the document as Y.Map objects
   * @returns An array of Y.Map objects
   */
  getYThreads() {
    return this.configuration.document.getArray(`${this.tiptapCollabConfigurationPrefix}threads`);
  }
  /**
   * Finds all threads in the document and returns them as JSON objects
   * @options Options to control the output of the threads (e.g. include deleted threads)
   * @returns An array of threads as JSON objects
   */
  getThreads(options) {
    const { types } = { ...defaultGetThreadsOptions, ...options };
    const threads = this.getYThreads().toJSON();
    if ((types === null || types === void 0 ? void 0 : types.includes("archived")) && (types === null || types === void 0 ? void 0 : types.includes("unarchived"))) {
      return threads;
    }
    return threads.filter((currentThead) => {
      if ((types === null || types === void 0 ? void 0 : types.includes("archived")) && currentThead.deletedAt) {
        return true;
      }
      if ((types === null || types === void 0 ? void 0 : types.includes("unarchived")) && !currentThead.deletedAt) {
        return true;
      }
      return false;
    });
  }
  /**
   * Find the index of a thread by its id
   * @param id The thread id
   * @returns The index of the thread or null if not found
   */
  getThreadIndex(id) {
    let index = null;
    let i = 0;
    for (const thread of this.getThreads({ types: ["archived", "unarchived"] })) {
      if (thread.id === id) {
        index = i;
        break;
      }
      i += 1;
    }
    return index;
  }
  /**
   * Gets a single thread by its id
   * @param id The thread id
   * @returns The thread as a JSON object or null if not found
   */
  getThread(id) {
    const index = this.getThreadIndex(id);
    if (index === null) {
      return null;
    }
    return this.getYThreads().get(index).toJSON();
  }
  /**
   * Gets a single thread by its id as a Y.Map object
   * @param id The thread id
   * @returns The thread as a Y.Map object or null if not found
   */
  getYThread(id) {
    const index = this.getThreadIndex(id);
    if (index === null) {
      return null;
    }
    return this.getYThreads().get(index);
  }
  /**
   * Create a new thread
   * @param data The thread data
   * @returns The created thread
   */
  createThread(data) {
    let createdThread = {};
    this.document.transact(() => {
      const thread = new YMap();
      thread.set("id", uuidv4());
      thread.set("createdAt", (/* @__PURE__ */ new Date()).toISOString());
      thread.set("comments", new YArray());
      thread.set("deletedComments", new YArray());
      thread.set("deletedAt", null);
      this.getYThreads().push([thread]);
      createdThread = this.updateThread(String(thread.get("id")), data);
    });
    return createdThread;
  }
  /**
   * Update a specific thread
   * @param id The thread id
   * @param data New data for the thread
   * @returns The updated thread or null if the thread is not found
   */
  updateThread(id, data) {
    let updatedThread = {};
    this.document.transact(() => {
      const thread = this.getYThread(id);
      if (thread === null) {
        return null;
      }
      thread.set("updatedAt", (/* @__PURE__ */ new Date()).toISOString());
      if (data.data) {
        thread.set("data", data.data);
      }
      if (data.resolvedAt || data.resolvedAt === null) {
        thread.set("resolvedAt", data.resolvedAt);
      }
      updatedThread = thread.toJSON();
    });
    return updatedThread;
  }
  /**
   * Handle the deletion of a thread. By default, the thread and it's comments are not deleted, but marked as deleted
   * via the `deletedAt` property. Forceful deletion can be enabled by setting the `force` option to `true`.
   *
   * If you only want to delete the comments of a thread, you can set the `deleteComments` option to `true`.
   * @param id The thread id
   * @param options A set of options that control how the thread is deleted
   * @returns The deleted thread or null if the thread is not found
   */
  deleteThread(id, options) {
    const { deleteComments, force } = { ...defaultDeleteThreadOptions, ...options };
    const index = this.getThreadIndex(id);
    if (index === null) {
      return null;
    }
    if (force) {
      this.getYThreads().delete(index, 1);
      return;
    }
    const thread = this.getYThreads().get(index);
    thread.set("deletedAt", (/* @__PURE__ */ new Date()).toISOString());
    if (deleteComments) {
      thread.set("comments", new YArray());
      thread.set("deletedComments", new YArray());
    }
    return thread.toJSON();
  }
  /**
   * Tries to restore a deleted thread
   * @param id The thread id
   * @returns The restored thread or null if the thread is not found
   */
  restoreThread(id) {
    const index = this.getThreadIndex(id);
    if (index === null) {
      return null;
    }
    const thread = this.getYThreads().get(index);
    thread.set("deletedAt", null);
    return thread.toJSON();
  }
  /**
   * Returns comments from a thread, either deleted or not
   * @param threadId The thread id
   * @param includeDeleted If you want to include deleted comments, defaults to `false`
   * @returns The comments or null if the thread is not found
   */
  getThreadComments(threadId, includeDeleted) {
    var _a, _b, _c;
    const index = this.getThreadIndex(threadId);
    if (index === null) {
      return null;
    }
    const comments = !includeDeleted ? (_a = this.getThread(threadId)) === null || _a === void 0 ? void 0 : _a.comments : [...((_b = this.getThread(threadId)) === null || _b === void 0 ? void 0 : _b.comments) || [], ...((_c = this.getThread(threadId)) === null || _c === void 0 ? void 0 : _c.deletedComments) || []].sort((a, b) => {
      return a.createdAt.localeCompare(b.createdAt);
    });
    return comments !== null && comments !== void 0 ? comments : [];
  }
  /**
   * Get a single comment from a specific thread
   * @param threadId The thread id
   * @param commentId The comment id
   * @param includeDeleted If you want to include deleted comments in the search
   * @returns The comment or null if not found
   */
  getThreadComment(threadId, commentId, includeDeleted) {
    var _a;
    const index = this.getThreadIndex(threadId);
    if (index === null) {
      return null;
    }
    const comments = this.getThreadComments(threadId, includeDeleted);
    return (_a = comments === null || comments === void 0 ? void 0 : comments.find((comment) => comment.id === commentId)) !== null && _a !== void 0 ? _a : null;
  }
  /**
   * Adds a comment to a thread
   * @param threadId The thread id
   * @param data The comment data
   * @returns The updated thread or null if the thread is not found
   * @example addComment('123', { content: 'Hello world', data: { author: 'Maria Doe' } })
   */
  addComment(threadId, data) {
    let updatedThread = {};
    this.document.transact(() => {
      const thread = this.getYThread(threadId);
      if (thread === null)
        return null;
      const commentMap = new YMap();
      commentMap.set("id", uuidv4());
      commentMap.set("createdAt", (/* @__PURE__ */ new Date()).toISOString());
      thread.get("comments").push([commentMap]);
      this.updateComment(threadId, String(commentMap.get("id")), data);
      updatedThread = thread.toJSON();
    });
    return updatedThread;
  }
  /**
   * Update a comment in a thread
   * @param threadId The thread id
   * @param commentId The comment id
   * @param data The new comment data
   * @returns The updated thread or null if the thread or comment is not found
   * @example updateComment('123', { content: 'The new content', data: { attachments: ['file1.jpg'] }})
   */
  updateComment(threadId, commentId, data) {
    let updatedThread = {};
    this.document.transact(() => {
      const thread = this.getYThread(threadId);
      if (thread === null)
        return null;
      let comment = null;
      for (const c of thread.get("comments")) {
        if (c.get("id") === commentId) {
          comment = c;
          break;
        }
      }
      if (comment === null)
        return null;
      comment.set("updatedAt", (/* @__PURE__ */ new Date()).toISOString());
      if (data.data) {
        comment.set("data", data.data);
      }
      if (data.content) {
        comment.set("content", data.content);
      }
      updatedThread = thread.toJSON();
    });
    return updatedThread;
  }
  /**
   * Deletes a comment from a thread
   * @param threadId The thread id
   * @param commentId The comment id
   * @param options A set of options that control how the comment is deleted
   * @returns The updated thread or null if the thread or comment is not found
   */
  deleteComment(threadId, commentId, options) {
    const { deleteContent, deleteThread } = { ...defaultDeleteCommentOptions, ...options };
    const thread = this.getYThread(threadId);
    if (thread === null)
      return null;
    let commentIndex = 0;
    for (const c of thread.get("comments")) {
      if (c.get("id") === commentId) {
        break;
      }
      commentIndex += 1;
    }
    if (commentIndex === 0 && (deleteThread || this.configuration.deleteThreadOnFirstCommentDelete)) {
      this.deleteThread(threadId);
      return;
    }
    const comment = thread.get("comments").get(commentIndex);
    const newComment = new YMap();
    newComment.set("id", comment.get("id"));
    newComment.set("createdAt", comment.get("createdAt"));
    newComment.set("updatedAt", (/* @__PURE__ */ new Date()).toISOString());
    newComment.set("deletedAt", (/* @__PURE__ */ new Date()).toISOString());
    newComment.set("data", comment.get("data"));
    newComment.set("content", deleteContent ? null : comment.get("content"));
    if (!thread.get("deletedComments")) {
      thread.set("deletedComments", new YArray());
    }
    thread.get("deletedComments").push([newComment]);
    thread.get("comments").delete(commentIndex);
    return thread.toJSON();
  }
  /**
   * Start watching threads for changes
   * @param callback The callback function to be called when a thread changes
   */
  watchThreads(callback) {
    this.getYThreads().observeDeep(callback);
  }
  /**
   * Stop watching threads for changes
   * @param callback The callback function to be removed
   */
  unwatchThreads(callback) {
    this.getYThreads().unobserveDeep(callback);
  }
};
export {
  AwarenessError,
  HocuspocusProvider,
  HocuspocusProviderWebsocket,
  MessageType,
  TiptapCollabProvider,
  TiptapCollabProviderWebsocket,
  WebSocketStatus
};
//# sourceMappingURL=@hocuspocus_provider.js.map
